{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\info 
{\title {\comment ascii_chart  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0.0 \par
}}ascii_chart}
{\comment Generated byDoxgyen. }
{\creatim \yr2020\mo7\dy16\hr15\min4\sec25}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt ascii_chart}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.0.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Thu Jul 16 2020 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Index\par \pard\plain 
{\tc \v Data Structure Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Data Structures\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the data structures with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b slice} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b ascii_chart.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ascii_chart_ps.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b constants.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Documentation{\tc \v Data Structure Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
slice Struct Reference\par \pard\plain 
{\tc\tcl2 \v slice}
{\xe \v slice}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b text}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 214} of file {\b ascii_chart.c}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v text\:slice}
{\xe \v slice\:text}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * slice::text}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 215} of file {\b ascii_chart.c}.}\par
{
Referenced by {\b main()}, and {\b read_stdin()}.}\par
}
{\xe \v value\:slice}
{\xe \v slice\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double slice::value}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 216} of file {\b ascii_chart.c}.}\par
{
Referenced by {\b main()}, and {\b read_stdin()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ascii_chart.c}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b ascii_chart_ps.c}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ascii_chart.c File Reference\par \pard\plain 
{\tc\tcl2 \v ascii_chart.c}
{\xe \v ascii_chart.c}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "constants.h"}\par
{\f2 #include <math.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <plot.h>}\par
{\f2 #include <libcommon.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ascii_chart.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "ascii__chart_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b slice}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b min}({\b X},  {\b Y})\~ (({\b X}) < ({\b Y}) ? ({\b X}) : ({\b Y}))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b max}({\b X},  {\b Y})\~ (({\b X}) > ({\b Y}) ? ({\b X}) : ({\b Y}))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VERSION}\~ "1.00 "\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LINECOLOR}\~ "black"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LINEWIDTH}\~ -1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAXSLICES}\~ 65\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LINE_BUFSIZ}\~ 256\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMMENTCHAR}\~ '#'\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b X}(radius,  angle)\~ (cos(angle)*(radius))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Y}(radius,  angle)\~ (sin(angle)*(radius))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RAD}(angle)\~ (((angle)/180.)*{\b M_PI})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XY}(radius,  angle)\~ ({\b X}((radius),{\b RAD}(angle))),({\b Y}((radius),{\b RAD}(angle)))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_version} (FILE *file)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b process_arguments} (int argc, char **argv, char **display_type, char **title, char **xtext, char **ytext, int *isPie, double *radius, double *text_distance, char *{\b colortable}[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_stdin} (int *n_slices, struct {\b slice} *slices[{\b MAXSLICES}])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char **argv)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b colortable} [{\b MAXSLICES}]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b progname}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v COMMENTCHAR\:ascii_chart.c}
{\xe \v ascii_chart.c\:COMMENTCHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMMENTCHAR\~ '#'}}
\par
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 177} of file {\b ascii_chart.c}.}\par
{
Referenced by {\b read_stdin()}.}\par
}
{\xe \v LINE_BUFSIZ\:ascii_chart.c}
{\xe \v ascii_chart.c\:LINE_BUFSIZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LINE_BUFSIZ\~ 256}}
\par
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 174} of file {\b ascii_chart.c}.}\par
{
Referenced by {\b read_stdin()}.}\par
}
{\xe \v LINECOLOR\:ascii_chart.c}
{\xe \v ascii_chart.c\:LINECOLOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LINECOLOR\~ "black"}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b ascii_chart.c}.}\par
{
Referenced by {\b main()}.}\par
}
{\xe \v LINEWIDTH\:ascii_chart.c}
{\xe \v ascii_chart.c\:LINEWIDTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LINEWIDTH\~ -1}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 164} of file {\b ascii_chart.c}.}\par
{
Referenced by {\b main()}.}\par
}
{\xe \v max\:ascii_chart.c}
{\xe \v ascii_chart.c\:max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define max( {\b X},  {\b Y})\~ (({\b X}) > ({\b Y}) ? ({\b X}) : ({\b Y}))}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b ascii_chart.c}.}\par
{
Referenced by {\b main()}.}\par
}
{\xe \v MAXSLICES\:ascii_chart.c}
{\xe \v ascii_chart.c\:MAXSLICES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAXSLICES\~ 65}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 173} of file {\b ascii_chart.c}.}\par
{
Referenced by {\b main()}.}\par
}
{\xe \v min\:ascii_chart.c}
{\xe \v ascii_chart.c\:min}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define min( {\b X},  {\b Y})\~ (({\b X}) < ({\b Y}) ? ({\b X}) : ({\b Y}))}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b ascii_chart.c}.}\par
}
{\xe \v RAD\:ascii_chart.c}
{\xe \v ascii_chart.c\:RAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RAD( angle)\~ (((angle)/180.)*{\b M_PI})}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VERSION\:ascii_chart.c}
{\xe \v ascii_chart.c\:VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VERSION\~ "1.00 "}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b ascii_chart.c}.}\par
{
Referenced by {\b print_version()}.}\par
}
{\xe \v X\:ascii_chart.c}
{\xe \v ascii_chart.c\:X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define X( radius,  angle)\~ (cos(angle)*(radius))}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v XY\:ascii_chart.c}
{\xe \v ascii_chart.c\:XY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XY( radius,  angle)\~ ({\b X}((radius),{\b RAD}(angle))),({\b Y}((radius),{\b RAD}(angle)))}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by {\b main()}.}\par
}
{\xe \v Y\:ascii_chart.c}
{\xe \v ascii_chart.c\:Y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Y( radius,  angle)\~ (sin(angle)*(radius))}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:ascii_chart.c}
{\xe \v ascii_chart.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int  {\i argc}, char **  {\i argv})}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 233} of file {\b ascii_chart.c}.}\par
{
References {\b colortable}, {\b LINECOLOR}, {\b LINEWIDTH}, {\b max}, {\b MAXSLICES}, {\b process_arguments()}, {\b read_stdin()}, {\b slice::text}, {\b slice::value}, and {\b XY}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   234 \{\par
  235    char * title="myPlot";       /* Title of the chart           */\par
  236    char * xtext="x_axis";       /* X axis Title of the chart            */\par
  237    char * mytext="y_axis";      /* Y axis Title of the chart            */\par
  238     int return_value;       /* return value for libplot calls.  */\par
  239     char *display_type = "meta";    /* default libplot output format    */\par
  240     int handle;         /* handle for open plotter      */\par
  241 \par
  242 struct slice *slices[MAXSLICES];/* the array of slices          */\par
  243 int n_slices=0;         /* number of slices in slices[] ;)  */\par
  244 int t;              /* loop var(s)              */\par
  245 double slice_max, sum;      /* max and sum of all slice values chris        */\par
  246 int neg_flag  ;   \par
  247                                 /* check all values > 0 chris */\par
  248 double radius=0.8;      /* radius of the circle in plot coords  */\par
  249 double text_distance=0;     /* distance of text from circle     */\par
  250 int isPie = 0 ;                 /* switch mode; chris */ \par
  251 \par
  252 double text_space  ;   \par
  253    \par
  254 /* vars for ymax */\par
  255    char buffer [55] ;    \par
  256    double ymax ;\par
  257     int ystep ;\par
  258     int nf [4] = \{ 2,5,2,0 \};\par
  259     int n = 1 ;\par
  260     ymax = 1.0 ;\par
  261     ystep = 0 ;\par
  262     \par
  263     \par
  264 process_arguments(argc,argv,\par
  265     &display_type,&title,&xtext,&mytext,&isPie,&radius,&text_distance,colortable);\par
  266 \par
  267 read_stdin(&n_slices,slices);\par
  268 \par
  269 /* Let us find the sum and  max and check for negative values */\par
  270 /* code added to by chris */   \par
  271 sum = 0 ;\par
  272 slice_max=1.;\par
  273 neg_flag = 0 ;   \par
  274    \par
  275 for(t=0;t<n_slices;t++)\par
  276      \{\par
  277      sum+=slices[t]->value;\par
  278      slice_max = max (slice_max,slices[t]->value) ;\par
  279      if ( slices [t]->value < 0 ) neg_flag ++ ; \par
  280      \}\par
  281 \par
  282 if ( neg_flag )\par
  283      \{\par
  284      fprintf(stderr,"Some data were apparently less than zero. \\nThis version of the program does not plot negative values.\\n");\par
  285      exit(1);\par
  286      \}\par
  287 /* initialising one plot session    */\par
  288                 /* specify type of plotter      */\par
  289 handle=pl_newpl(display_type, NULL, stdout, stderr);\par
  290 if(handle<0)\par
  291 \{   fprintf(stderr,"The plotter could not be created.\\n");\par
  292     exit(1);\par
  293 \}\par
  294 \par
  295 return_value=pl_selectpl(handle);          \par
  296 if(return_value<0)\par
  297 \{   fprintf(stderr,"The plotter does not exist or could not be selected.\\n");\par
  298     exit(1);\par
  299 \}\par
  300 \par
  301 return_value= pl_openpl();\par
  302 if(return_value<0)\par
  303 \{   fprintf(stderr,"The selected plotter could not be opened!\\n");\par
  304     exit(1);\par
  305 \}\par
  306 \par
  307 /* now decide to plot bar or pie */\par
  308 if ( isPie ) \par
  309      \{\par
  310                 /* creating your user coordinates   */\par
  311 if(title)\par
  312     return_value= pl_fspace(-1.4,-1.4,1.4,1.4);\par
  313 else\par
  314     return_value= pl_fspace(-1.2,-1.2,1.2,1.2);\par
  315 if(return_value)\par
  316 \{   fprintf(stderr,"fspace returned %d!\\n",return_value);   \}\par
  317 \par
  318 \par
  319 /* we should be ready to plot pie, now! */\par
  320 \par
  321 \par
  322 \par
  323                 /* i like to think in degrees.      */\par
  324 #define X(radius,angle) (cos(angle)*(radius))\par
  325 #define Y(radius,angle) (sin(angle)*(radius))\par
  326 \par
  327 #define RAD(angle) (((angle)/180.)*M_PI)\par
  328 \par
  329 #define XY(radius,angle) (X((radius),RAD(angle))),(Y((radius),RAD(angle)))\par
  330 \par
  331 /* plot title if there is one */\par
  332 if(title&&*title)\par
  333 \{\par
  334     pl_fmove(0,radius+text_distance+0.2);\par
  335     pl_alabel('c','b',title);\par
  336 \}\par
  337 \par
  338 pl_pencolorname(LINECOLOR);\par
  339 \par
  340 /* and now for the slices       */\par
  341 \{\par
  342     double distance,angle=0;\par
  343     char **color=colortable;\par
  344     double r=radius;            /*the radius of the slice circle*/\par
  345 \par
  346     pl_savestate();\par
  347     pl_joinmod("round");\par
  348 \par
  349                 /* drawing the slices           */\par
  350     \par
  351     pl_filltype(1);\par
  352     pl_flinewidth(LINEWIDTH);\par
  353     pl_pencolorname(LINECOLOR);\par
  354     for(t=0;t<n_slices;t++)\par
  355                 /* draw one path for every slice    */\par
  356     \{\par
  357         distance=(slices[t]->value/sum)*360.;\par
  358         pl_fillcolorname(*color);\par
  359                 \par
  360     pl_fmove(0,0);      /* start at center..            */\par
  361     pl_fcont(XY(r,angle));  \par
  362         if(distance>179)\par
  363         \{           /* we need to draw a semicircle first   */\par
  364                 /* we have to be sure to draw \par
  365                    counterclockwise (180 wouldn`t work \par
  366                    in all cases)            */\par
  367         pl_farc(0,0,XY(r,angle),XY(r,angle+179)); \par
  368         angle+=179; \par
  369         distance-=179;\par
  370         \}\par
  371     pl_farc(0,0,XY(r,angle),XY(r,angle+distance));\par
  372     pl_fcont(0,0);      /* return to center         */\par
  373     pl_endpath();       /* not really necessary, but intuitive  */\par
  374     \par
  375     angle+=distance;    /* log fraction of circle already drawn */\par
  376                  \par
  377     color++;        /* next color for next slice        */\par
  378     if(!*color) color=colortable;/* start over if all colors used   */\par
  379     \}\par
  380 \par
  381                     /* the closing circle and middle point  */\par
  382                 /* only, if LINEWIDTH!=default  */\par
  383     if(LINEWIDTH!=-1)\par
  384     \{\par
  385                 /* add %5 to compensate for arc obstrution*/\par
  386         pl_flinewidth(LINEWIDTH*1.2);\par
  387 \par
  388     pl_filltype(0);\par
  389     pl_fcircle(0.,0.,r);    \par
  390 \par
  391     pl_colorname(LINECOLOR);\par
  392     pl_filltype(1);\par
  393     pl_fpoint(0,0); \par
  394     \}\par
  395                     \par
  396     pl_restorestate();\par
  397 \}\par
  398 \par
  399 /* and now for the text     */\par
  400 \{\par
  401     double distance,angle=0,place;\par
  402     double r=radius+text_distance;/* radius of circle where text is placed*/\par
  403     char h,v;\par
  404     pl_savestate();\par
  405 \par
  406     for(t=0;t<n_slices;t++) \par
  407     \{\par
  408         distance=(slices[t]->value/sum)*360.;\par
  409                     /* let us calculate the position ...    */\par
  410     place=angle+0.5*distance;\par
  411                 /* and the alignment            */\par
  412     if(place<180)\par
  413         v='b';\par
  414     else\par
  415         v='t';\par
  416     if(place<90 || place>270)\par
  417         h='l';\par
  418     else\par
  419         h='r';\par
  420                 /* plot now!                */\par
  421     pl_fmove(XY(r,place));\par
  422     pl_alabel(h,v,slices[t]->text);\par
  423     \par
  424     angle+=distance;\par
  425     \}\par
  426                     \par
  427     pl_restorestate();\par
  428 \}\par
  429 \par
  430 \par
  431     \par
  432      \} /* end of is Pie */\par
  433 else \par
  434      \{  /* next part plots bars , chris */\par
  435     if(title || xtext || mytext)\par
  436       \{\par
  437          text_space = -2.0 - text_distance ;\par
  438       \}\par
  439     else\par
  440       \{\par
  441          text_space = -1.0 - text_distance ;         \par
  442       \}\par
  443      /* x0, y0, x1 y1 but it has to be square for the fonts*/\par
  444     return_value= pl_fspace(text_space / radius, \par
  445                 text_space / radius, \par
  446                 (10.0 - text_space) / radius, \par
  447                 (10.0 - text_space) / radius );\par
  448 if(return_value)\par
  449 \{   fprintf(stderr,"fspace returned %d!\\n",return_value);   \}\par
  450 \par
  451 \par
  452 /* we should be ready to plot bars, now! */\par
  453 \par
  454 \par
  455  \par
  456 /* plot title if there is one */\par
  457 if(title&&*title)\par
  458 \{\par
  459         pl_ffontsize (0.5);\par
  460         pl_fmove( 5, 11 ) ;\par
  461     pl_alabel('c','c',title); /* centered */\par
  462 \}\par
  463 /* plot X axis title if there is one */\par
  464 if(xtext&&*xtext)\par
  465 \{\par
  466         pl_ffontsize (0.5);\par
  467         pl_fmove( 5, 0.7 * text_space ) ;\par
  468     pl_alabel('c','c',xtext); /* cnetered */\par
  469 \}\par
  470 /* plot Y axis title if there is one */\par
  471 if(mytext&&*mytext)\par
  472 \{\par
  473         pl_ffontsize (0.5);\par
  474         pl_fmove( 0.8 * text_space, 6 ) ;\par
  475         pl_ftextangle (90);\par
  476     pl_alabel('c','c',mytext); \par
  477         pl_ftextangle (0); \par
  478 \}\par
  479 /* find y max */\par
  480     \par
  481     while ( ymax < slice_max )\par
  482        \{\par
  483       ymax = ymax * nf [n] ;\par
  484       n ++ ;\par
  485       if ( nf[n] ) n = 0 ;\par
  486        \}\par
  487     pl_line ( 0,0,0, 10.0 *  ymax / slice_max  );\par
  488 /* plot Y axis */\par
  489     while ( ystep < ymax ) \par
  490      \{\par
  491     pl_fline ( -0.3, 10 * (double) ystep/ slice_max ,0.0, 10 * ystep / slice_max );\par
  492     pl_fmove ( 0.3 * text_space , 10 * (double) ystep / slice_max  );\par
  493     sprintf ( buffer, "%d", ystep );\par
  494     pl_alabel ( 'r','c', buffer );  \par
  495     ystep = ystep + ymax / 10;\par
  496     if (ystep < 1 ) ystep ++ ;\par
  497      \}  \par
  498 \par
  499 \par
  500      pl_pencolorname(LINECOLOR);\par
  501 \par
  502 /* and now for the bars     */\par
  503 \{\par
  504 \par
  505     char **color=colortable;\par
  506 \par
  507     pl_savestate();\par
  508     pl_joinmod("round");\par
  509     \par
  510     pl_filltype(1);\par
  511     pl_flinewidth(LINEWIDTH);\par
  512     pl_pencolorname(LINECOLOR);\par
  513     for(t=0;t<n_slices;t++)\par
  514 \par
  515     \{\par
  516         pl_fillcolorname(*color);\par
  517         pl_fbox (10.0 * (double)(t)/(double)(n_slices),\par
  518          0,\par
  519          10.0 * (double)(t+1)/(double)(n_slices),\par
  520          10 * slices[t]->value/slice_max );\par
  521     color++;        /* next color for next slice        */\par
  522     if(!*color) color=colortable;/* start over if all colors used   */\par
  523     \} /* end of for each slice */\par
  524 \par
  525     pl_restorestate();\par
  526 \}\par
  527 \par
  528 /* and now for the text     */\par
  529 \{\par
  530     char just ;\par
  531     just = 'c';\par
  532    \par
  533     pl_savestate();\par
  534     pl_ffontsize (0.4);\par
  535     if (n_slices > 5)\par
  536      \{\par
  537     pl_ftextangle (90); /* degrees */\par
  538     just = 'r' ;\par
  539      \}\par
  540     for(t=0;t<n_slices;t++) \par
  541     \{\par
  542 /* plot now!                */\par
  543     pl_fmove(10.0 * (double)(t+0.5)/(double)(n_slices),\par
  544          0.3 * text_space );\par
  545     pl_alabel(just, 'c' ,slices[t]->text);\par
  546     \}\par
  547     pl_restorestate();\par
  548 \}\par
  549      \} /* end of is ! Pie */\par
  550 \par
  551                 /* end a plot sesssion          */\par
  552 return_value= pl_closepl();\par
  553 if(return_value<0)\par
  554 \{   fprintf(stderr,"The plotter could not be closed.\\n");\par
  555     /* no exit, because we try to delete the plotter        */\par
  556 \}\par
  557                 \par
  558 /* need to select a different plotter in order to deleter our       */\par
  559 return_value=pl_selectpl(0);\par
  560 if(return_value<0)\par
  561 \{   fprintf(stderr,"Default Plotter could not be selected!\\n");\par
  562 \}\par
  563 \par
  564 return_value=pl_deletepl (handle);/* clean up by deleting used plotter  */\par
  565 if(return_value<0)\par
  566 \{   fprintf(stderr,"Selected Plotter could not be deleted!\\n");\par
  567 \}\par
  568 \par
  569             \par
  570 return 0;\par
  571 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "ascii__chart_8c_a3c04138a5bfe5d72780bb7e82a18e627_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v print_version\:ascii_chart.c}
{\xe \v ascii_chart.c\:print_version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_version (FILE *  {\i file})}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b ascii_chart.c}.}\par
{
References {\b VERSION}.}\par
{
Referenced by {\b process_arguments()}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    74 \{\par
   75              fprintf(file,"ascii_chart version " VERSION "\\n"); \par
   76              fprintf(file,"Copyright (C) 1998 - 2020" \par
   77         "by Bernhard Reiter & Chris Elliott, \\n"\par
   78         "updated by Francesco Lazzarotto. \\n"\par
   79                     "The GNU GENERAL PUBLIC LICENSE v3 applies. "\par
   80                         "Absolutly No Warranty!\\n");\par
   81 #ifdef DEBUG\par
   82              fprintf(file,"compiled with option: DEBUG\\n"); \par
   83 #endif\par
   84 \}\par
}
}
{\xe \v process_arguments\:ascii_chart.c}
{\xe \v ascii_chart.c\:process_arguments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void process_arguments (int  {\i argc}, char **  {\i argv}, char **  {\i display_type}, char **  {\i title}, char **  {\i xtext}, char **  {\i ytext}, int *  {\i isPie}, double *  {\i radius}, double *  {\i text_distance}, char *  {\i colortable}[])}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 578} of file {\b ascii_chart.c}.}\par
{
References {\b colortable}, {\b print_version()}, and {\b progname}.}\par
{
Referenced by {\b main()}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   581 \{\par
  582 /* well, we do not have the gnu getopt long here. :-( \par
  583  * so i use getopt for now\par
  584  */\par
  585           int c;        \par
  586           extern char *optarg;\par
  587       /* optint,opterr,optopt relate to getopt(),see manpage*/\par
  588       /* but we do not use them so far          */\par
  589           /* extern int optind,opterr,optopt; */ \par
  590           int errflg = 0;\par
  591           int show_usage=0;\par
  592           int show_version=0;\par
  593       int specified_display_type=0;\par
  594       char **help;  /* will help splitting the colornames   */\par
  595       char * arg;   /* one string argument          */\par
  596 *isPie = 0 ; /* ie do a bar chart */\par
  597 progname=argv[0];   /* fill the only global variable    */\par
  598 \par
  599           while ((c = getopt(argc, argv, "Vt:T:r:d:C:h:X:Y:P")) != EOF)\par
  600                switch (c) \{\par
  601 /* chris did some debugging here */\par
  602         case 't':\par
  603 #ifdef DEBUG\par
  604         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  605 #endif        \par
  606                          *title=xstrdup(optarg);\par
  607 #ifdef DEBUG\par
  608           fprintf (stderr, "OK \\n");\par
  609 #endif        \par
  610           break;\par
  611         case 'X':\par
  612 #ifdef DEBUG\par
  613         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  614 #endif        \par
  615                          *xtext=xstrdup(optarg);\par
  616 #ifdef DEBUG\par
  617           fprintf (stderr, "OK \\n");\par
  618 #endif        \par
  619           break;\par
  620         case 'Y':\par
  621 #ifdef DEBUG\par
  622         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  623 #endif        \par
  624                          *ytext=xstrdup(optarg);\par
  625 #ifdef DEBUG\par
  626           fprintf (stderr, "OK \\n");\par
  627 #endif        \par
  628           break;\par
  629           \par
  630                case 'T':\par
  631 #ifdef DEBUG\par
  632         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  633 #endif        \par
  634                     if (specified_display_type)\par
  635                          errflg++;\par
  636                     else \{\par
  637                 specified_display_type++;\par
  638                 *display_type = xstrdup(optarg);\par
  639             \}\par
  640 #ifdef DEBUG\par
  641           fprintf (stderr, "OK \\n");\par
  642 #endif        \par
  643           break;\par
  644            case 'P':\par
  645 #ifdef DEBUG\par
  646         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  647 #endif        \par
  648                 *isPie = 1 ;\par
  649 /* ie try to plot as pie chart */                   \par
  650 #ifdef DEBUG\par
  651         fprintf(stderr," OK \\n");\par
  652 #endif        \par
  653           break;\par
  654 \par
  655         case 'r':\par
  656 #ifdef DEBUG\par
  657         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  658 #endif        \par
  659                 *radius=atof(optarg);\par
  660                 if(*radius<0.1||*radius>1.2)\par
  661                 errflg++;\par
  662 #ifdef DEBUG\par
  663           fprintf (stderr, "OK \\n");\par
  664 #endif        \par
  665           break;\par
  666             \par
  667            case 'd':\par
  668 #ifdef DEBUG\par
  669         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  670 #endif        \par
  671                 *text_distance=atof(optarg);\par
  672                 if(*text_distance<(-2.0)||*text_distance>1.2)\par
  673                 errflg++;\par
  674             /* we have a second check after processing all options*/\par
  675 #ifdef DEBUG\par
  676           fprintf (stderr, "OK \\n");\par
  677 #endif        \par
  678           break;\par
  679             \par
  680            case 'C':\par
  681 #ifdef DEBUG\par
  682         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  683 #endif        \par
  684             help=colortable;\par
  685             arg=xstrdup(optarg);\par
  686             *help++=strtok(arg,",\\0");\par
  687             if(!*help)\par
  688                 errflg++;\par
  689             else\par
  690                 while((*(help++)=strtok(NULL,",\\0")));\par
  691 #ifdef DEBUG\par
  692           fprintf (stderr, "OK \\n");\par
  693 #endif        \par
  694           break;\par
  695             \par
  696                case 'V':\par
  697 #ifdef DEBUG\par
  698         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  699 #endif        \par
  700                     if (show_version)\par
  701                          errflg++;\par
  702                     else\par
  703                          show_version++;\par
  704 #ifdef DEBUG\par
  705           fprintf (stderr, "OK \\n");\par
  706 #endif        \par
  707           break;\par
  708                case 'h':\par
  709 #ifdef DEBUG\par
  710         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  711 #endif        \par
  712                     if (show_usage)\par
  713                          errflg++;\par
  714                     else\par
  715                          show_usage++;\par
  716 #ifdef DEBUG\par
  717           fprintf (stderr, "OK \\n");\par
  718 #endif        \par
  719           break;\par
  720                case '?':\par
  721 #ifdef DEBUG\par
  722         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  723 #endif        \par
  724                     errflg++;\par
  725                \}\par
  726                     /* check if text_distance is reasonable */\par
  727       if(*text_distance< (-*radius)) errflg++;\par
  728       if (! (*isPie) ) *radius = sqrt ( *radius ) ; /* for bar charts only */\par
  729                                            /* or else the size gets too small to see */\par
  730           if (errflg) \{ \par
  731                fprintf(stderr, "parameters were bad!\\n");\par
  732                show_usage++;\par
  733           \}\par
  734           if(show_version)\par
  735           \{\par
  736              print_version(stdout); \par
  737              exit(1);\par
  738           \}\par
  739           if(show_usage)\par
  740           \{ FILE *f=stdout;\par
  741         if(errflg)\par
  742                     f=stderr;\par
  743         else    f=stdout;\par
  744          print_version(f);\par
  745         \par
  746              fprintf(f,"usage: %s [options]\\n",progname); \par
  747              fprintf(f,"\\t the stdin is read once.\\n");\par
  748              fprintf(f,"\\t options are:\\n"\\\par
  749                     "\\t\\t-P Use Pie rather than Bar chart ( not -X -Y )\\n"\\\par
  750                     "\\t\\t-t Title\\tset \\"Title\\" as chart title\\n"\\\par
  751                     "\\t\\t-X XTitle\\tset \\"XTitle\\" as barchart X axis title\\n"\\\par
  752                     "\\t\\t-Y YTitle\\tset \\"YTitle\\" as barchart Y axis title\\n"\\\par
  753                     "\\t\\t-T Display-Type\\tone of "\\\par
  754                 "X, ps, fig, hpgl, tek, meta, ai, pnm, gif\\n"\\\par
  755             "\\t\\t\\t\\t(or whatever your libplot version supports)\\n"\\\par
  756             "\\t\\t\\t\\t(meta is the default)\\n"\\\par
  757                     "\\t\\t-r size of chart\\tfloat out of [0.1;1.2] default:0.8\\n"\\\par
  758                     "\\t\\t-d textdistance around chart \\tfloat out of "\\\par
  759                         "[-radius;1.2] default:0.0\\n"\\\par
  760             "\\t\\t-C colornames\\tcomma separated list of colornames\\n"\\\par
  761             "\\t\\t\\t\\t(see valid names in color.txt of plotutils doc.)\\n"\\\par
  762                     "\\t\\t-h\\t\\tprint this help and exit\\n"\\\par
  763                     "\\t\\t-V\\t\\tprint version and exit\\n"\\\par
  764                     );\par
  765              \par
  766              exit(1);\par
  767           \}\par
  768 \par
  769 /* Everything is fine with the options now ... */\par
  770 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "ascii__chart_8c_a219229f3ebcf2131152ab1c224d926b4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v read_stdin\:ascii_chart.c}
{\xe \v ascii_chart.c\:read_stdin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_stdin (int *  {\i n_slices}, struct {\b slice} *  {\i slices}[MAXSLICES])}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 773} of file {\b ascii_chart.c}.}\par
{
References {\b COMMENTCHAR}, {\b LINE_BUFSIZ}, {\b progname}, {\b slice::text}, and {\b slice::value}.}\par
{
Referenced by {\b main()}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   774 \{\par
  775 char line [LINE_BUFSIZ];        /* input line buffer            */\par
  776 \par
  777 /* So, let us read the standardinput */\par
  778 while( !(feof(stdin) || ferror(stdin)) )\par
  779 \{\par
  780 char *c;            /* string return from fgets     */\par
  781 struct slice * aslice;      /* freshly filled slice-structure   */\par
  782 int r;              /* help variable for scanning       */\par
  783 char *s,*t;         /* help variables for scanning      */\par
  784 \par
  785     c=fgets(line,LINE_BUFSIZ,stdin);\par
  786     if(!c) continue;    /* encountered error of eof     */\par
  787     if(line[strlen(line)-1]!='\\n')\par
  788     \{\par
  789         fprintf(stderr,"line was too long!\\n");\par
  790         exit(2);\par
  791     \}\par
  792                 /* strip newline */\par
  793     line[strlen(line)-1]='\\0';\par
  794                 /* strip carridge return, if there is one*/\par
  795     if(line[strlen(line)-1]=='\\r') \par
  796         line[strlen(line)-1]='\\0';\par
  797     \par
  798                 /* Skip empty lines or lines beginning  \par
  799                  * with COMMENTCHAR         */\par
  800     if(!(line[0]==COMMENTCHAR || !(line) || strlen(line)==0))\par
  801     \{\par
  802 #ifdef DEBUG\par
  803         fprintf(stderr,"Scanning line: %s\\n",line);\par
  804 #endif\par
  805         aslice=malloc(sizeof(struct slice));\par
  806         if(!aslice)\par
  807             perror(progname),exit(10);\par
  808             \par
  809             \par
  810                 /* scanning the last part\par
  811                  * after a tab or space as number   */\par
  812                  \par
  813                 /* delete trailing tabs and spaces  */\par
  814         r=strlen(line);\par
  815         while(r>0 && (line[r-1]==' ' || line[r-1]=='\\t') )\par
  816             line[r---1]='\\0';\par
  817                 /* scan for last tab or space       */\par
  818         s=strrchr(line,' ');\par
  819         t=strrchr(line,'\\t');\par
  820         s=(s>t?s:t);    /* which is the last white-space?   */\par
  821             \par
  822                 /*use full string,if no whitespace found\par
  823                 else copy text up to whitespace\par
  824                 and get enough memory           */\par
  825         if(s==NULL) \par
  826         \{\par
  827             if(!(aslice->text=malloc(1))) \par
  828                 perror(progname),exit(10);\par
  829             aslice->text[0]='\\0'; \par
  830             s=line;\par
  831         \} else\par
  832         \{   \par
  833             if(!(aslice->text=malloc(strlen(line)-strlen(s)+1))) \par
  834                 perror(progname),exit(10);\par
  835             strncpy(aslice->text,line, strlen(line)-strlen(s));\par
  836                 /*some systems don`t terminate target \par
  837                 string in strncpy, so we have to do it  */\par
  838             aslice->text[strlen(line)-strlen(s)]='\\0';\par
  839         \}\par
  840         \par
  841                 /* scan last string for number      */\par
  842         r=sscanf(s,"%lf",&aslice->value);\par
  843         if(r!=1)\par
  844             fprintf(stderr,"number in line couldn`t be scanned\\n"),\par
  845                 exit(8);\par
  846         \par
  847         if(*n_slices>=MAXSLICES)\par
  848             fprintf(stderr,"too many slices\\n"),exit(8);\par
  849             \par
  850         slices[(*n_slices)++]=aslice;\par
  851     \}\par
  852 \}\par
  853 \par
  854 if(ferror(stdin))\par
  855 \{\par
  856     perror(progname);\par
  857     exit(5);\par
  858 \}\par
  859 \par
  860 #ifdef DEBUG\par
  861 fprintf(stderr,"Read %d slices!\\n",*n_slices);\par
  862 #endif \par
  863 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v colortable\:ascii_chart.c}
{\xe \v ascii_chart.c\:colortable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* colortable[{\b MAXSLICES}]}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{  \par
   "red",  "blue",   "green", "yellow", \par
 "firebrick",  "aliceblue","greenyellow",  "wheat",\par
NULL\par
\}\par
}
{
Definition at line {\b 187} of file {\b ascii_chart.c}.}\par
{
Referenced by {\b main()}, and {\b process_arguments()}.}\par
}
{\xe \v progname\:ascii_chart.c}
{\xe \v ascii_chart.c\:progname}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* progname}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 220} of file {\b ascii_chart.c}.}\par
{
Referenced by {\b process_arguments()}, and {\b read_stdin()}.}\par
}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ascii_chart.c\par \pard\plain 
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     1 /* code modified Sept 1999 to produce bar charts as well as pies\par
    2  * Copyright (C) 1999 Chris Elliott ( cje2@york.ac.uk ) and Bernhard Reiter \par
    3  * GNU public licence still applies\par
    4  * -X labels X axis of bar chart -Y labels Y axis of chart\par
    5  * \par
    6  * v0.05 bug with -Y often giving a seg fault traced to fault on optarg list\par
    7  * v0.1 -r adius and -d istance options control size in  bar chart\par
    8  */\par
    9 \par
   10 /* Bernhard Reiter  Fri Oct 10 20:07:12 MET DST 1997\par
   11  * $Id: piechart.c,v 1.11 1999/04/03 10:26:32 breiter Exp $\par
   12  *\par
   13  * Copyright (C) 1997,1998 by Bernhard Reiter \par
   14  * \par
   15  *    This program is free software; you can redistribute it and/or\par
   16  *   modify it under the terms of the GNU General Public License\par
   17  *   as published by the Free Software Foundation; either version 2\par
   18  *   of the License, or (at your option) any later version.\par
   19  *\par
   20  *   This program is distributed in the hope that it will be useful,\par
   21  *   but WITHOUT ANY WARRANTY; without even the implied warranty of\par
   22  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\par
   23  *   GNU General Public License for more details.\par
   24  *\par
   25  *   You should have received a copy of the GNU General Public License\par
   26  *   along with this program; if not, write to the Free Software\par
   27  *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\par
   28  *\par
   29  *  \par
   30  *  Creates bar or piechart, must be linked with a libplot library\par
   31  *  reads ascii input file from stdin.\par
   32  *\par
   33  *  format: one slice per line. every trailing tab and space will\par
   34  *      be ignored. The string after the last tab or space is\par
   35  *      will be scanned as value. The beginnign is the label-text.\par
   36  *      Empty lines and lines starting with "#" are ignored\par
   37  *\par
   38  *  TODO: many improvements possible.\par
   39  *      - make stuff more dynamic (input linelength and max # of slices)\par
   40  *      - better handling of progname\par
   41  *      - move much stuff into command line options\par
   42  *      e.g.    \par
   43  *          + fonts\par
   44  *          + rotation of the pie\par
   45  *      - use getopt_long\par
   46  *      - make better assumptions on how to place the labels\par
   47  *      - add printing percentage numbers and values;as options\par
   48  *      - special handling of very small slices\par
   49  *      - make multi line labels possible\par
   50  *      - multi-line titles?\par
   51  *      - does every system have xstrdup(), strncpy()?\par
   52  *      - \par
   53  *      ...\par
   54  *\par
   55  *  THANKS: To "Martin J. Evans" <martin@mjedev.demon.co.uk>\par
   56  *      for pointing out that some systems do not terminate\par
   57  *      the target string after strncpy().\par
   58  *      \par
   59  *      Jan-Oliver Wagner <jwagner@usf.uni-osnabrueck.de>\par
   60  *      created first version ito work with gnuplotutils-2.2.\par
   61  */\par
   62 #include "constants.h"\par
   63 #include <math.h>\par
   64 #include <stdio.h>\par
   65 #include <plot.h>\par
   66 #include <libcommon.h>\par
   67 \par
   68 #define min(X, Y)  ((X) < (Y) ? (X) : (Y))\par
   69 #define max(X, Y)  ((X) > (Y) ? (X) : (Y))\par
   70 \par
   71 \par
   72 #define VERSION "1.00 "\par
   73 void print_version(FILE *file)\par
   74 \{\par
   75              fprintf(file,"ascii_chart version " VERSION "\\n"); \par
   76              fprintf(file,"Copyright (C) 1998 - 2020" \par
   77         "by Bernhard Reiter & Chris Elliott, \\n"\par
   78         "updated by Francesco Lazzarotto. \\n"\par
   79                     "The GNU GENERAL PUBLIC LICENSE v3 applies. "\par
   80                         "Absolutly No Warranty!\\n");\par
   81 #ifdef DEBUG\par
   82              fprintf(file,"compiled with option: DEBUG\\n"); \par
   83 #endif\par
   84 \}\par
   85 \par
   86 /*\par
   87  * $Log: piechart.c,v $\par
   88  * Revision 1.11  1999/04/03  10:26:32  breiter\par
   89  * adapted to plotutils-2.2: added pl_ to all function calls\par
   90  * adjusted help text\par
   91  * more return values are checked now, as the function provide more of them\par
   92  * end circle and middle point are only drawn if LINEWIDTH is not default\par
   93  * changed constant name LINEWIDTH_LINES -> LINEWIDTH\par
   94  * end circle and middle point LINEWIDTH is multiplied with a factor(~1.2) now\par
   95  * extra external variables for getopt() are commented out\par
   96  *\par
   97  * Revision 1.10  1998/07/28  13:41:54  breiter\par
   98  * - Terminating strncpy()ed string now. Thanks to "Martin J. Evans"\par
   99  * for reporting this problem.\par
  100  * - Removed hard limit on label-size.\par
  101  * - Changed inputline buffersize to a new constant defined as LINE_BUFSIZ.\par
  102  * - Cleaned up some comments.\par
  103  * version number incremented to 0.8\par
  104  *\par
  105  * Revision 1.9  1998/07/07  23:44:26  breiter\par
  106  * added -C option for specifing colors\par
  107  * version number is 0.7 now.\par
  108  *\par
  109  * Revision 1.8  1998/07/07  17:04:40  breiter\par
  110  * major improvements:\par
  111  * - more structure: moves code into functions: process_arguments(),read_stdin()\par
  112  * - new scanning -> multi word labels are possible now\par
  113  * - two new options: -r radius and -d text distance\par
  114  * - errmsgs and usage are printed to stderr now, but to stdout, wenn requested\par
  115  * - fixed debug output typo\par
  116  *\par
  117  * Revision 1.7  1998/01/31  16:13:02  breiter\par
  118  * changed fill() -> filltype() as fill() is only temporarily supported\par
  119  *\par
  120  * Revision 1.6  1998/01/31  16:05:40  breiter\par
  121  * using a path to draw one slice now. This is far simpler.\par
  122  * No need for LINEWIDTH_FILL anymore.\par
  123  *\par
  124  * Revision 1.5  1998/01/30  16:06:37  breiter\par
  125  * adapted for use with libplot from plotutils-2.0\par
  126  * added +T display-type commandline option therefore.\par
  127  *\par
  128  * Revision 1.4  1997/10/11  17:19:14  breiter\par
  129  * cosmetic changes. version information enhanced.\par
  130  *\par
  131  * Revision 1.3  1997/10/11  16:31:56  breiter\par
  132  * version information enhanced.\par
  133  *\par
  134  * Revision 1.2  1997/10/11  16:09:15  breiter\par
  135  * bug fixes. small improvements. userspace is always square now.\par
  136  *\par
  137  * Revision 1.1  1997/10/11  15:07:27  breiter\par
  138  * Initial revision\par
  139  *\par
  140  */\par
  141 \par
  142 #include <stdlib.h>\par
  143 #include <math.h>\par
  144 #include <string.h>     /* for xstrdup() */\par
  145      \par
  146 /* this program used getopt and relys on that it is included in the \par
  147  * stdlib. I wanted to use getopt_long from Gnu, but it is not included\par
  148  * in the clib i have here. So it is still left TODO.\par
  149  */\par
  150 \par
  151 /*******************************************************************************\par
  152  * Configurations -- change, what you like\par
  153  *  If time permits some stuff could be influenced by command line options\par
  154  ******************************************************************************/\par
  155 \par
  156 /*  Color in which the separating lines and the circle are drawn\par
  157  */\par
  158 #define LINECOLOR "black"\par
  159 \par
  160 /* LINEWIDTH is for the separating lines and the arcs\par
  161  * if closing circle and middle point will be drawn, a factor will be applied\par
  162  * -1 means default ; 0.02 might be a usefull value\par
  163  */\par
  164 #define LINEWIDTH -1\par
  165 \par
  166 /* Some hardcoded limits:\par
  167  * the max number of slices (^=MAXSLICES).\par
  168  * LINE_BUFSIZ is the maxmumlength of input-lines.\par
  169  *(You see, how lasy i was. I was not using some object orientated language\par
  170  *  like objective-c and left all the neat dynamic string handling for\par
  171  *  the interested hacker and or some version in the future.)\par
  172  */\par
  173 #define MAXSLICES 65\par
  174 #define LINE_BUFSIZ 256\par
  175 \par
  176 /* if an input line starts with this character, it is ignored.      */\par
  177 #define COMMENTCHAR '#'\par
  178 \par
  179 /* Colors the slices are getting filled with.\par
  180  * the color names are feed into the libplot functions.\par
  181  * The plotutils distribution contains a file doc/colors.txt which lists the\par
  182  * recogized names.\par
  183  *\par
  184  * if the nullpointer is reached the color pointer is resetted starting\par
  185  * with the first color again.\par
  186  */\par
  187 char *colortable[MAXSLICES] = \{  /* colors changed by chris */\par
  188    "red",  "blue",   "green", "yellow", \par
  189  "firebrick",  "aliceblue","greenyellow",  "wheat",\par
  190 NULL\par
  191 \};\par
  192 \par
  193 \par
  194 /*******************************************************************************\par
  195  * Beware: This following code is for hackers only.\par
  196  *  ( Yeah, it is not THAT bad, you can risk a look, if you know some C ..)\par
  197  ******************************************************************************/\par
  198 \par
  199 /* Program structure outline:\par
  200  *  - get all options \par
  201  *  - read all input data (only from stdin so far)\par
  202  *  - print\par
  203  *      + init stuff\par
  204  *      + print title\par
  205  *      + print color part for slices\par
  206  *      + print separating lines and circle\par
  207  *      + print labels\par
  208  *      + clean up stuff\par
  209  */\par
  210 \par
  211 \par
  212 /* A nice structure, we will fill some of it, when we read the input.\par
  213  */\par
  214 struct slice \{\par
  215     char *text;     /* label for the slice          */\par
  216     double value;       /* value for the slice          */\par
  217 \};\par
  218 \par
  219 /* one global variable. It is needed everywhere..               */\par
  220 char * progname;        /*  for printing errors out     */\par
  221 \par
  222 \par
  223 /* declarations of functions defined after main()           \par
  224  */\par
  225 void process_arguments(int argc, char **argv, \par
  226     char **display_type, char ** title, char ** xtext, char ** ytext,\par
  227     int * isPie, double *radius, double *text_distance, char *colortable[]);\par
  228 void read_stdin(int *n_slices, struct slice *slices[MAXSLICES]);\par
  229 \par
  230 \par
  231 /* Attention: Main Progam to be started.... :)              */\par
  232 \par
  233 int main(int argc, char **argv)\par
  234 \{\par
  235    char * title="myPlot";       /* Title of the chart           */\par
  236    char * xtext="x_axis";       /* X axis Title of the chart            */\par
  237    char * mytext="y_axis";      /* Y axis Title of the chart            */\par
  238     int return_value;       /* return value for libplot calls.  */\par
  239     char *display_type = "meta";    /* default libplot output format    */\par
  240     int handle;         /* handle for open plotter      */\par
  241 \par
  242 struct slice *slices[MAXSLICES];/* the array of slices          */\par
  243 int n_slices=0;         /* number of slices in slices[] ;)  */\par
  244 int t;              /* loop var(s)              */\par
  245 double slice_max, sum;      /* max and sum of all slice values chris        */\par
  246 int neg_flag  ;   \par
  247                                 /* check all values > 0 chris */\par
  248 double radius=0.8;      /* radius of the circle in plot coords  */\par
  249 double text_distance=0;     /* distance of text from circle     */\par
  250 int isPie = 0 ;                 /* switch mode; chris */ \par
  251 \par
  252 double text_space  ;   \par
  253    \par
  254 /* vars for ymax */\par
  255    char buffer [55] ;    \par
  256    double ymax ;\par
  257     int ystep ;\par
  258     int nf [4] = \{ 2,5,2,0 \};\par
  259     int n = 1 ;\par
  260     ymax = 1.0 ;\par
  261     ystep = 0 ;\par
  262     \par
  263     \par
  264 process_arguments(argc,argv,\par
  265     &display_type,&title,&xtext,&mytext,&isPie,&radius,&text_distance,colortable);\par
  266 \par
  267 read_stdin(&n_slices,slices);\par
  268 \par
  269 /* Let us find the sum and  max and check for negative values */\par
  270 /* code added to by chris */   \par
  271 sum = 0 ;\par
  272 slice_max=1.;\par
  273 neg_flag = 0 ;   \par
  274    \par
  275 for(t=0;t<n_slices;t++)\par
  276      \{\par
  277      sum+=slices[t]->value;\par
  278      slice_max = max (slice_max,slices[t]->value) ;\par
  279      if ( slices [t]->value < 0 ) neg_flag ++ ; \par
  280      \}\par
  281 \par
  282 if ( neg_flag )\par
  283      \{\par
  284      fprintf(stderr,"Some data were apparently less than zero. \\nThis version of the program does not plot negative values.\\n");\par
  285      exit(1);\par
  286      \}\par
  287 /* initialising one plot session    */\par
  288                 /* specify type of plotter      */\par
  289 handle=pl_newpl(display_type, NULL, stdout, stderr);\par
  290 if(handle<0)\par
  291 \{   fprintf(stderr,"The plotter could not be created.\\n");\par
  292     exit(1);\par
  293 \}\par
  294 \par
  295 return_value=pl_selectpl(handle);          \par
  296 if(return_value<0)\par
  297 \{   fprintf(stderr,"The plotter does not exist or could not be selected.\\n");\par
  298     exit(1);\par
  299 \}\par
  300 \par
  301 return_value= pl_openpl();\par
  302 if(return_value<0)\par
  303 \{   fprintf(stderr,"The selected plotter could not be opened!\\n");\par
  304     exit(1);\par
  305 \}\par
  306 \par
  307 /* now decide to plot bar or pie */\par
  308 if ( isPie ) \par
  309      \{\par
  310                 /* creating your user coordinates   */\par
  311 if(title)\par
  312     return_value= pl_fspace(-1.4,-1.4,1.4,1.4);\par
  313 else\par
  314     return_value= pl_fspace(-1.2,-1.2,1.2,1.2);\par
  315 if(return_value)\par
  316 \{   fprintf(stderr,"fspace returned %d!\\n",return_value);   \}\par
  317 \par
  318 \par
  319 /* we should be ready to plot pie, now! */\par
  320 \par
  321 \par
  322 \par
  323                 /* i like to think in degrees.      */\par
  324 #define X(radius,angle) (cos(angle)*(radius))\par
  325 #define Y(radius,angle) (sin(angle)*(radius))\par
  326 \par
  327 #define RAD(angle) (((angle)/180.)*M_PI)\par
  328 \par
  329 #define XY(radius,angle) (X((radius),RAD(angle))),(Y((radius),RAD(angle)))\par
  330 \par
  331 /* plot title if there is one */\par
  332 if(title&&*title)\par
  333 \{\par
  334     pl_fmove(0,radius+text_distance+0.2);\par
  335     pl_alabel('c','b',title);\par
  336 \}\par
  337 \par
  338 pl_pencolorname(LINECOLOR);\par
  339 \par
  340 /* and now for the slices       */\par
  341 \{\par
  342     double distance,angle=0;\par
  343     char **color=colortable;\par
  344     double r=radius;            /*the radius of the slice circle*/\par
  345 \par
  346     pl_savestate();\par
  347     pl_joinmod("round");\par
  348 \par
  349                 /* drawing the slices           */\par
  350     \par
  351     pl_filltype(1);\par
  352     pl_flinewidth(LINEWIDTH);\par
  353     pl_pencolorname(LINECOLOR);\par
  354     for(t=0;t<n_slices;t++)\par
  355                 /* draw one path for every slice    */\par
  356     \{\par
  357         distance=(slices[t]->value/sum)*360.;\par
  358         pl_fillcolorname(*color);\par
  359                 \par
  360     pl_fmove(0,0);      /* start at center..            */\par
  361     pl_fcont(XY(r,angle));  \par
  362         if(distance>179)\par
  363         \{           /* we need to draw a semicircle first   */\par
  364                 /* we have to be sure to draw \par
  365                    counterclockwise (180 wouldn`t work \par
  366                    in all cases)            */\par
  367         pl_farc(0,0,XY(r,angle),XY(r,angle+179)); \par
  368         angle+=179; \par
  369         distance-=179;\par
  370         \}\par
  371     pl_farc(0,0,XY(r,angle),XY(r,angle+distance));\par
  372     pl_fcont(0,0);      /* return to center         */\par
  373     pl_endpath();       /* not really necessary, but intuitive  */\par
  374     \par
  375     angle+=distance;    /* log fraction of circle already drawn */\par
  376                  \par
  377     color++;        /* next color for next slice        */\par
  378     if(!*color) color=colortable;/* start over if all colors used   */\par
  379     \}\par
  380 \par
  381                     /* the closing circle and middle point  */\par
  382                 /* only, if LINEWIDTH!=default  */\par
  383     if(LINEWIDTH!=-1)\par
  384     \{\par
  385                 /* add %5 to compensate for arc obstrution*/\par
  386         pl_flinewidth(LINEWIDTH*1.2);\par
  387 \par
  388     pl_filltype(0);\par
  389     pl_fcircle(0.,0.,r);    \par
  390 \par
  391     pl_colorname(LINECOLOR);\par
  392     pl_filltype(1);\par
  393     pl_fpoint(0,0); \par
  394     \}\par
  395                     \par
  396     pl_restorestate();\par
  397 \}\par
  398 \par
  399 /* and now for the text     */\par
  400 \{\par
  401     double distance,angle=0,place;\par
  402     double r=radius+text_distance;/* radius of circle where text is placed*/\par
  403     char h,v;\par
  404     pl_savestate();\par
  405 \par
  406     for(t=0;t<n_slices;t++) \par
  407     \{\par
  408         distance=(slices[t]->value/sum)*360.;\par
  409                     /* let us calculate the position ...    */\par
  410     place=angle+0.5*distance;\par
  411                 /* and the alignment            */\par
  412     if(place<180)\par
  413         v='b';\par
  414     else\par
  415         v='t';\par
  416     if(place<90 || place>270)\par
  417         h='l';\par
  418     else\par
  419         h='r';\par
  420                 /* plot now!                */\par
  421     pl_fmove(XY(r,place));\par
  422     pl_alabel(h,v,slices[t]->text);\par
  423     \par
  424     angle+=distance;\par
  425     \}\par
  426                     \par
  427     pl_restorestate();\par
  428 \}\par
  429 \par
  430 \par
  431     \par
  432      \} /* end of is Pie */\par
  433 else \par
  434      \{  /* next part plots bars , chris */\par
  435     if(title || xtext || mytext)\par
  436       \{\par
  437          text_space = -2.0 - text_distance ;\par
  438       \}\par
  439     else\par
  440       \{\par
  441          text_space = -1.0 - text_distance ;         \par
  442       \}\par
  443      /* x0, y0, x1 y1 but it has to be square for the fonts*/\par
  444     return_value= pl_fspace(text_space / radius, \par
  445                 text_space / radius, \par
  446                 (10.0 - text_space) / radius, \par
  447                 (10.0 - text_space) / radius );\par
  448 if(return_value)\par
  449 \{   fprintf(stderr,"fspace returned %d!\\n",return_value);   \}\par
  450 \par
  451 \par
  452 /* we should be ready to plot bars, now! */\par
  453 \par
  454 \par
  455  \par
  456 /* plot title if there is one */\par
  457 if(title&&*title)\par
  458 \{\par
  459         pl_ffontsize (0.5);\par
  460         pl_fmove( 5, 11 ) ;\par
  461     pl_alabel('c','c',title); /* centered */\par
  462 \}\par
  463 /* plot X axis title if there is one */\par
  464 if(xtext&&*xtext)\par
  465 \{\par
  466         pl_ffontsize (0.5);\par
  467         pl_fmove( 5, 0.7 * text_space ) ;\par
  468     pl_alabel('c','c',xtext); /* cnetered */\par
  469 \}\par
  470 /* plot Y axis title if there is one */\par
  471 if(mytext&&*mytext)\par
  472 \{\par
  473         pl_ffontsize (0.5);\par
  474         pl_fmove( 0.8 * text_space, 6 ) ;\par
  475         pl_ftextangle (90);\par
  476     pl_alabel('c','c',mytext); \par
  477         pl_ftextangle (0); \par
  478 \}\par
  479 /* find y max */\par
  480     \par
  481     while ( ymax < slice_max )\par
  482        \{\par
  483       ymax = ymax * nf [n] ;\par
  484       n ++ ;\par
  485       if ( nf[n] ) n = 0 ;\par
  486        \}\par
  487     pl_line ( 0,0,0, 10.0 *  ymax / slice_max  );\par
  488 /* plot Y axis */\par
  489     while ( ystep < ymax ) \par
  490      \{\par
  491     pl_fline ( -0.3, 10 * (double) ystep/ slice_max ,0.0, 10 * ystep / slice_max );\par
  492     pl_fmove ( 0.3 * text_space , 10 * (double) ystep / slice_max  );\par
  493     sprintf ( buffer, "%d", ystep );\par
  494     pl_alabel ( 'r','c', buffer );  \par
  495     ystep = ystep + ymax / 10;\par
  496     if (ystep < 1 ) ystep ++ ;\par
  497      \}  \par
  498 \par
  499 \par
  500      pl_pencolorname(LINECOLOR);\par
  501 \par
  502 /* and now for the bars     */\par
  503 \{\par
  504 \par
  505     char **color=colortable;\par
  506 \par
  507     pl_savestate();\par
  508     pl_joinmod("round");\par
  509     \par
  510     pl_filltype(1);\par
  511     pl_flinewidth(LINEWIDTH);\par
  512     pl_pencolorname(LINECOLOR);\par
  513     for(t=0;t<n_slices;t++)\par
  514 \par
  515     \{\par
  516         pl_fillcolorname(*color);\par
  517         pl_fbox (10.0 * (double)(t)/(double)(n_slices),\par
  518          0,\par
  519          10.0 * (double)(t+1)/(double)(n_slices),\par
  520          10 * slices[t]->value/slice_max );\par
  521     color++;        /* next color for next slice        */\par
  522     if(!*color) color=colortable;/* start over if all colors used   */\par
  523     \} /* end of for each slice */\par
  524 \par
  525     pl_restorestate();\par
  526 \}\par
  527 \par
  528 /* and now for the text     */\par
  529 \{\par
  530     char just ;\par
  531     just = 'c';\par
  532    \par
  533     pl_savestate();\par
  534     pl_ffontsize (0.4);\par
  535     if (n_slices > 5)\par
  536      \{\par
  537     pl_ftextangle (90); /* degrees */\par
  538     just = 'r' ;\par
  539      \}\par
  540     for(t=0;t<n_slices;t++) \par
  541     \{\par
  542 /* plot now!                */\par
  543     pl_fmove(10.0 * (double)(t+0.5)/(double)(n_slices),\par
  544          0.3 * text_space );\par
  545     pl_alabel(just, 'c' ,slices[t]->text);\par
  546     \}\par
  547     pl_restorestate();\par
  548 \}\par
  549      \} /* end of is ! Pie */\par
  550 \par
  551                 /* end a plot sesssion          */\par
  552 return_value= pl_closepl();\par
  553 if(return_value<0)\par
  554 \{   fprintf(stderr,"The plotter could not be closed.\\n");\par
  555     /* no exit, because we try to delete the plotter        */\par
  556 \}\par
  557                 \par
  558 /* need to select a different plotter in order to deleter our       */\par
  559 return_value=pl_selectpl(0);\par
  560 if(return_value<0)\par
  561 \{   fprintf(stderr,"Default Plotter could not be selected!\\n");\par
  562 \}\par
  563 \par
  564 return_value=pl_deletepl (handle);/* clean up by deleting used plotter  */\par
  565 if(return_value<0)\par
  566 \{   fprintf(stderr,"Selected Plotter could not be deleted!\\n");\par
  567 \}\par
  568 \par
  569             \par
  570 return 0;\par
  571 \}\par
  572 \par
  573 \par
  574 /************************************************************************\par
  575  * functions\par
  576  */\par
  577  \par
  578 void process_arguments( int argc, char **argv, \par
  579     char **display_type, char ** title, char ** xtext, char ** ytext,\par
  580     int * isPie, double *radius, double *text_distance,char *colortable[])\par
  581 \{\par
  582 /* well, we do not have the gnu getopt long here. :-( \par
  583  * so i use getopt for now\par
  584  */\par
  585           int c;        \par
  586           extern char *optarg;\par
  587       /* optint,opterr,optopt relate to getopt(),see manpage*/\par
  588       /* but we do not use them so far          */\par
  589           /* extern int optind,opterr,optopt; */ \par
  590           int errflg = 0;\par
  591           int show_usage=0;\par
  592           int show_version=0;\par
  593       int specified_display_type=0;\par
  594       char **help;  /* will help splitting the colornames   */\par
  595       char * arg;   /* one string argument          */\par
  596 *isPie = 0 ; /* ie do a bar chart */\par
  597 progname=argv[0];   /* fill the only global variable    */\par
  598 \par
  599           while ((c = getopt(argc, argv, "Vt:T:r:d:C:h:X:Y:P")) != EOF)\par
  600                switch (c) \{\par
  601 /* chris did some debugging here */\par
  602         case 't':\par
  603 #ifdef DEBUG\par
  604         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  605 #endif        \par
  606                          *title=xstrdup(optarg);\par
  607 #ifdef DEBUG\par
  608           fprintf (stderr, "OK \\n");\par
  609 #endif        \par
  610           break;\par
  611         case 'X':\par
  612 #ifdef DEBUG\par
  613         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  614 #endif        \par
  615                          *xtext=xstrdup(optarg);\par
  616 #ifdef DEBUG\par
  617           fprintf (stderr, "OK \\n");\par
  618 #endif        \par
  619           break;\par
  620         case 'Y':\par
  621 #ifdef DEBUG\par
  622         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  623 #endif        \par
  624                          *ytext=xstrdup(optarg);\par
  625 #ifdef DEBUG\par
  626           fprintf (stderr, "OK \\n");\par
  627 #endif        \par
  628           break;\par
  629           \par
  630                case 'T':\par
  631 #ifdef DEBUG\par
  632         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  633 #endif        \par
  634                     if (specified_display_type)\par
  635                          errflg++;\par
  636                     else \{\par
  637                 specified_display_type++;\par
  638                 *display_type = xstrdup(optarg);\par
  639             \}\par
  640 #ifdef DEBUG\par
  641           fprintf (stderr, "OK \\n");\par
  642 #endif        \par
  643           break;\par
  644            case 'P':\par
  645 #ifdef DEBUG\par
  646         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  647 #endif        \par
  648                 *isPie = 1 ;\par
  649 /* ie try to plot as pie chart */                   \par
  650 #ifdef DEBUG\par
  651         fprintf(stderr," OK \\n");\par
  652 #endif        \par
  653           break;\par
  654 \par
  655         case 'r':\par
  656 #ifdef DEBUG\par
  657         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  658 #endif        \par
  659                 *radius=atof(optarg);\par
  660                 if(*radius<0.1||*radius>1.2)\par
  661                 errflg++;\par
  662 #ifdef DEBUG\par
  663           fprintf (stderr, "OK \\n");\par
  664 #endif        \par
  665           break;\par
  666             \par
  667            case 'd':\par
  668 #ifdef DEBUG\par
  669         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  670 #endif        \par
  671                 *text_distance=atof(optarg);\par
  672                 if(*text_distance<(-2.0)||*text_distance>1.2)\par
  673                 errflg++;\par
  674             /* we have a second check after processing all options*/\par
  675 #ifdef DEBUG\par
  676           fprintf (stderr, "OK \\n");\par
  677 #endif        \par
  678           break;\par
  679             \par
  680            case 'C':\par
  681 #ifdef DEBUG\par
  682         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  683 #endif        \par
  684             help=colortable;\par
  685             arg=xstrdup(optarg);\par
  686             *help++=strtok(arg,",\\0");\par
  687             if(!*help)\par
  688                 errflg++;\par
  689             else\par
  690                 while((*(help++)=strtok(NULL,",\\0")));\par
  691 #ifdef DEBUG\par
  692           fprintf (stderr, "OK \\n");\par
  693 #endif        \par
  694           break;\par
  695             \par
  696                case 'V':\par
  697 #ifdef DEBUG\par
  698         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  699 #endif        \par
  700                     if (show_version)\par
  701                          errflg++;\par
  702                     else\par
  703                          show_version++;\par
  704 #ifdef DEBUG\par
  705           fprintf (stderr, "OK \\n");\par
  706 #endif        \par
  707           break;\par
  708                case 'h':\par
  709 #ifdef DEBUG\par
  710         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  711 #endif        \par
  712                     if (show_usage)\par
  713                          errflg++;\par
  714                     else\par
  715                          show_usage++;\par
  716 #ifdef DEBUG\par
  717           fprintf (stderr, "OK \\n");\par
  718 #endif        \par
  719           break;\par
  720                case '?':\par
  721 #ifdef DEBUG\par
  722         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  723 #endif        \par
  724                     errflg++;\par
  725                \}\par
  726                     /* check if text_distance is reasonable */\par
  727       if(*text_distance< (-*radius)) errflg++;\par
  728       if (! (*isPie) ) *radius = sqrt ( *radius ) ; /* for bar charts only */\par
  729                                            /* or else the size gets too small to see */\par
  730           if (errflg) \{ \par
  731                fprintf(stderr, "parameters were bad!\\n");\par
  732                show_usage++;\par
  733           \}\par
  734           if(show_version)\par
  735           \{\par
  736              print_version(stdout); \par
  737              exit(1);\par
  738           \}\par
  739           if(show_usage)\par
  740           \{ FILE *f=stdout;\par
  741         if(errflg)\par
  742                     f=stderr;\par
  743         else    f=stdout;\par
  744          print_version(f);\par
  745         \par
  746              fprintf(f,"usage: %s [options]\\n",progname); \par
  747              fprintf(f,"\\t the stdin is read once.\\n");\par
  748              fprintf(f,"\\t options are:\\n"\\\par
  749                     "\\t\\t-P Use Pie rather than Bar chart ( not -X -Y )\\n"\\\par
  750                     "\\t\\t-t Title\\tset \\"Title\\" as chart title\\n"\\\par
  751                     "\\t\\t-X XTitle\\tset \\"XTitle\\" as barchart X axis title\\n"\\\par
  752                     "\\t\\t-Y YTitle\\tset \\"YTitle\\" as barchart Y axis title\\n"\\\par
  753                     "\\t\\t-T Display-Type\\tone of "\\\par
  754                 "X, ps, fig, hpgl, tek, meta, ai, pnm, gif\\n"\\\par
  755             "\\t\\t\\t\\t(or whatever your libplot version supports)\\n"\\\par
  756             "\\t\\t\\t\\t(meta is the default)\\n"\\\par
  757                     "\\t\\t-r size of chart\\tfloat out of [0.1;1.2] default:0.8\\n"\\\par
  758                     "\\t\\t-d textdistance around chart \\tfloat out of "\\\par
  759                         "[-radius;1.2] default:0.0\\n"\\\par
  760             "\\t\\t-C colornames\\tcomma separated list of colornames\\n"\\\par
  761             "\\t\\t\\t\\t(see valid names in color.txt of plotutils doc.)\\n"\\\par
  762                     "\\t\\t-h\\t\\tprint this help and exit\\n"\\\par
  763                     "\\t\\t-V\\t\\tprint version and exit\\n"\\\par
  764                     );\par
  765              \par
  766              exit(1);\par
  767           \}\par
  768 \par
  769 /* Everything is fine with the options now ... */\par
  770 \}\par
  771 \par
  772 \par
  773 void read_stdin(int *n_slices, struct slice *slices[MAXSLICES])\par
  774 \{\par
  775 char line [LINE_BUFSIZ];        /* input line buffer            */\par
  776 \par
  777 /* So, let us read the standardinput */\par
  778 while( !(feof(stdin) || ferror(stdin)) )\par
  779 \{\par
  780 char *c;            /* string return from fgets     */\par
  781 struct slice * aslice;      /* freshly filled slice-structure   */\par
  782 int r;              /* help variable for scanning       */\par
  783 char *s,*t;         /* help variables for scanning      */\par
  784 \par
  785     c=fgets(line,LINE_BUFSIZ,stdin);\par
  786     if(!c) continue;    /* encountered error of eof     */\par
  787     if(line[strlen(line)-1]!='\\n')\par
  788     \{\par
  789         fprintf(stderr,"line was too long!\\n");\par
  790         exit(2);\par
  791     \}\par
  792                 /* strip newline */\par
  793     line[strlen(line)-1]='\\0';\par
  794                 /* strip carridge return, if there is one*/\par
  795     if(line[strlen(line)-1]=='\\r') \par
  796         line[strlen(line)-1]='\\0';\par
  797     \par
  798                 /* Skip empty lines or lines beginning  \par
  799                  * with COMMENTCHAR         */\par
  800     if(!(line[0]==COMMENTCHAR || !(line) || strlen(line)==0))\par
  801     \{\par
  802 #ifdef DEBUG\par
  803         fprintf(stderr,"Scanning line: %s\\n",line);\par
  804 #endif\par
  805         aslice=malloc(sizeof(struct slice));\par
  806         if(!aslice)\par
  807             perror(progname),exit(10);\par
  808             \par
  809             \par
  810                 /* scanning the last part\par
  811                  * after a tab or space as number   */\par
  812                  \par
  813                 /* delete trailing tabs and spaces  */\par
  814         r=strlen(line);\par
  815         while(r>0 && (line[r-1]==' ' || line[r-1]=='\\t') )\par
  816             line[r---1]='\\0';\par
  817                 /* scan for last tab or space       */\par
  818         s=strrchr(line,' ');\par
  819         t=strrchr(line,'\\t');\par
  820         s=(s>t?s:t);    /* which is the last white-space?   */\par
  821             \par
  822                 /*use full string,if no whitespace found\par
  823                 else copy text up to whitespace\par
  824                 and get enough memory           */\par
  825         if(s==NULL) \par
  826         \{\par
  827             if(!(aslice->text=malloc(1))) \par
  828                 perror(progname),exit(10);\par
  829             aslice->text[0]='\\0'; \par
  830             s=line;\par
  831         \} else\par
  832         \{   \par
  833             if(!(aslice->text=malloc(strlen(line)-strlen(s)+1))) \par
  834                 perror(progname),exit(10);\par
  835             strncpy(aslice->text,line, strlen(line)-strlen(s));\par
  836                 /*some systems don`t terminate target \par
  837                 string in strncpy, so we have to do it  */\par
  838             aslice->text[strlen(line)-strlen(s)]='\\0';\par
  839         \}\par
  840         \par
  841                 /* scan last string for number      */\par
  842         r=sscanf(s,"%lf",&aslice->value);\par
  843         if(r!=1)\par
  844             fprintf(stderr,"number in line couldn`t be scanned\\n"),\par
  845                 exit(8);\par
  846         \par
  847         if(*n_slices>=MAXSLICES)\par
  848             fprintf(stderr,"too many slices\\n"),exit(8);\par
  849             \par
  850         slices[(*n_slices)++]=aslice;\par
  851     \}\par
  852 \}\par
  853 \par
  854 if(ferror(stdin))\par
  855 \{\par
  856     perror(progname);\par
  857     exit(5);\par
  858 \}\par
  859 \par
  860 #ifdef DEBUG\par
  861 fprintf(stderr,"Read %d slices!\\n",*n_slices);\par
  862 #endif \par
  863 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ascii_chart_ps.c File Reference\par \pard\plain 
{\tc\tcl2 \v ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "constants.h"}\par
{\f2 #include <math.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <plot.h>}\par
{\f2 #include <libcommon.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for ascii_chart_ps.c:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "ascii__chart__ps_8c__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b slice}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b min}({\b X},  {\b Y})\~ (({\b X}) < ({\b Y}) ? ({\b X}) : ({\b Y}))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b max}({\b X},  {\b Y})\~ (({\b X}) > ({\b Y}) ? ({\b X}) : ({\b Y}))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b VERSION}\~ "1.00 "\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LINECOLOR}\~ "black"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LINEWIDTH}\~ -1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAXSLICES}\~ 65\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LINE_BUFSIZ}\~ 256\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b COMMENTCHAR}\~ '#'\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b X}(radius,  angle)\~ (cos(angle)*(radius))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Y}(radius,  angle)\~ (sin(angle)*(radius))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RAD}(angle)\~ (((angle)/180.)*{\b M_PI})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b XY}(radius,  angle)\~ ({\b X}((radius),{\b RAD}(angle))),({\b Y}((radius),{\b RAD}(angle)))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print_version} (FILE *file)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b process_arguments} (int argc, char **argv, char **display_type, char **title, char **xtext, char **ytext, int *isPie, double *radius, double *text_distance, char *{\b colortable}[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b read_stdin} (int *n_slices, struct {\b slice} *slices[{\b MAXSLICES}])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char **argv)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b colortable} [{\b MAXSLICES}]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b progname}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v COMMENTCHAR\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:COMMENTCHAR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define COMMENTCHAR\~ '#'}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 177} of file {\b ascii_chart_ps.c}.}\par
{
Referenced by {\b read_stdin()}.}\par
}
{\xe \v LINE_BUFSIZ\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:LINE_BUFSIZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LINE_BUFSIZ\~ 256}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 174} of file {\b ascii_chart_ps.c}.}\par
{
Referenced by {\b read_stdin()}.}\par
}
{\xe \v LINECOLOR\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:LINECOLOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LINECOLOR\~ "black"}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b ascii_chart_ps.c}.}\par
{
Referenced by {\b main()}.}\par
}
{\xe \v LINEWIDTH\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:LINEWIDTH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LINEWIDTH\~ -1}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 164} of file {\b ascii_chart_ps.c}.}\par
{
Referenced by {\b main()}.}\par
}
{\xe \v max\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define max( {\b X},  {\b Y})\~ (({\b X}) > ({\b Y}) ? ({\b X}) : ({\b Y}))}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 69} of file {\b ascii_chart_ps.c}.}\par
{
Referenced by {\b main()}.}\par
}
{\xe \v MAXSLICES\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:MAXSLICES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAXSLICES\~ 65}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 173} of file {\b ascii_chart_ps.c}.}\par
{
Referenced by {\b main()}.}\par
}
{\xe \v min\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:min}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define min( {\b X},  {\b Y})\~ (({\b X}) < ({\b Y}) ? ({\b X}) : ({\b Y}))}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b ascii_chart_ps.c}.}\par
}
{\xe \v RAD\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:RAD}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RAD( angle)\~ (((angle)/180.)*{\b M_PI})}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v VERSION\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define VERSION\~ "1.00 "}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 72} of file {\b ascii_chart_ps.c}.}\par
{
Referenced by {\b print_version()}.}\par
}
{\xe \v X\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define X( radius,  angle)\~ (cos(angle)*(radius))}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v XY\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:XY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define XY( radius,  angle)\~ ({\b X}((radius),{\b RAD}(angle))),({\b Y}((radius),{\b RAD}(angle)))}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by {\b main()}.}\par
}
{\xe \v Y\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:Y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Y( radius,  angle)\~ (sin(angle)*(radius))}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int  {\i argc}, char **  {\i argv})}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 233} of file {\b ascii_chart_ps.c}.}\par
{
References {\b colortable}, {\b LINECOLOR}, {\b LINEWIDTH}, {\b max}, {\b MAXSLICES}, {\b process_arguments()}, {\b read_stdin()}, {\b slice::text}, {\b slice::value}, and {\b XY}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   234 \{\par
  235    char * title="myPlot";       /* Title of the chart           */\par
  236    char * xtext="x_axis";       /* X axis Title of the chart            */\par
  237    char * mytext="y_axis";      /* Y axis Title of the chart            */\par
  238 int return_value;       /* return value for libplot calls.  */\par
  239 char *display_type = "ps";  /* default libplot output format    */\par
  240 int handle;         /* handle for open plotter      */\par
  241 \par
  242 struct slice *slices[MAXSLICES];/* the array of slices          */\par
  243 int n_slices=0;         /* number of slices in slices[] ;)  */\par
  244 int t;              /* loop var(s)              */\par
  245 double slice_max, sum;      /* max and sum of all slice values chris        */\par
  246 int neg_flag  ;   \par
  247                                 /* check all values > 0 chris */\par
  248 double radius=0.8;      /* radius of the circle in plot coords  */\par
  249 double text_distance=0;     /* distance of text from circle     */\par
  250 int isPie = 0 ;                 /* switch mode; chris */ \par
  251 \par
  252 double text_space  ;   \par
  253    \par
  254 /* vars for ymax */\par
  255    char buffer [55] ;    \par
  256    double ymax ;\par
  257     int ystep ;\par
  258     int nf [4] = \{ 2,5,2,0 \};\par
  259     int n = 1 ;\par
  260     ymax = 1.0 ;\par
  261     ystep = 0 ;\par
  262     \par
  263     \par
  264 process_arguments(argc,argv,\par
  265     &display_type,&title,&xtext,&mytext,&isPie,&radius,&text_distance,colortable);\par
  266 \par
  267 read_stdin(&n_slices,slices);\par
  268 \par
  269 /* Let us find the sum and  max and check for negative values */\par
  270 /* code added to by chris */   \par
  271 sum = 0 ;\par
  272 slice_max=1.;\par
  273 neg_flag = 0 ;   \par
  274    \par
  275 for(t=0;t<n_slices;t++)\par
  276      \{\par
  277      sum+=slices[t]->value;\par
  278      slice_max = max (slice_max,slices[t]->value) ;\par
  279      if ( slices [t]->value < 0 ) neg_flag ++ ; \par
  280      \}\par
  281 \par
  282 if ( neg_flag )\par
  283      \{\par
  284      fprintf(stderr,"Some data were apparently less than zero. \\nThis version of the program does not plot negative values.\\n");\par
  285      exit(1);\par
  286      \}\par
  287 /* initialising one plot session    */\par
  288                 /* specify type of plotter      */\par
  289 handle=pl_newpl(display_type, NULL, stdout, stderr);\par
  290 if(handle<0)\par
  291 \{   fprintf(stderr,"The plotter could not be created.\\n");\par
  292     exit(1);\par
  293 \}\par
  294 \par
  295 return_value=pl_selectpl(handle);          \par
  296 if(return_value<0)\par
  297 \{   fprintf(stderr,"The plotter does not exist or could not be selected.\\n");\par
  298     exit(1);\par
  299 \}\par
  300 \par
  301 return_value= pl_openpl();\par
  302 if(return_value<0)\par
  303 \{   fprintf(stderr,"The selected plotter could not be opened!\\n");\par
  304     exit(1);\par
  305 \}\par
  306 \par
  307 /* now decide to plot bar or pie */\par
  308 if ( isPie ) \par
  309      \{\par
  310                 /* creating your user coordinates   */\par
  311 if(title)\par
  312     return_value= pl_fspace(-1.4,-1.4,1.4,1.4);\par
  313 else\par
  314     return_value= pl_fspace(-1.2,-1.2,1.2,1.2);\par
  315 if(return_value)\par
  316 \{   fprintf(stderr,"fspace returned %d!\\n",return_value);   \}\par
  317 \par
  318 \par
  319 /* we should be ready to plot pie, now! */\par
  320 \par
  321 \par
  322 \par
  323                 /* i like to think in degrees.      */\par
  324 #define X(radius,angle) (cos(angle)*(radius))\par
  325 #define Y(radius,angle) (sin(angle)*(radius))\par
  326 \par
  327 #define RAD(angle) (((angle)/180.)*M_PI)\par
  328 \par
  329 #define XY(radius,angle) (X((radius),RAD(angle))),(Y((radius),RAD(angle)))\par
  330 \par
  331 /* plot title if there is one */\par
  332 if(title&&*title)\par
  333 \{\par
  334     pl_fmove(0,radius+text_distance+0.2);\par
  335     pl_alabel('c','b',title);\par
  336 \}\par
  337 \par
  338 pl_pencolorname(LINECOLOR);\par
  339 \par
  340 /* and now for the slices       */\par
  341 \{\par
  342     double distance,angle=0;\par
  343     char **color=colortable;\par
  344     double r=radius;            /*the radius of the slice circle*/\par
  345 \par
  346     pl_savestate();\par
  347     pl_joinmod("round");\par
  348 \par
  349                 /* drawing the slices           */\par
  350     \par
  351     pl_filltype(1);\par
  352     pl_flinewidth(LINEWIDTH);\par
  353     pl_pencolorname(LINECOLOR);\par
  354     for(t=0;t<n_slices;t++)\par
  355                 /* draw one path for every slice    */\par
  356     \{\par
  357         distance=(slices[t]->value/sum)*360.;\par
  358         pl_fillcolorname(*color);\par
  359                 \par
  360     pl_fmove(0,0);      /* start at center..            */\par
  361     pl_fcont(XY(r,angle));  \par
  362         if(distance>179)\par
  363         \{           /* we need to draw a semicircle first   */\par
  364                 /* we have to be sure to draw \par
  365                    counterclockwise (180 wouldn`t work \par
  366                    in all cases)            */\par
  367         pl_farc(0,0,XY(r,angle),XY(r,angle+179)); \par
  368         angle+=179; \par
  369         distance-=179;\par
  370         \}\par
  371     pl_farc(0,0,XY(r,angle),XY(r,angle+distance));\par
  372     pl_fcont(0,0);      /* return to center         */\par
  373     pl_endpath();       /* not really necessary, but intuitive  */\par
  374     \par
  375     angle+=distance;    /* log fraction of circle already drawn */\par
  376                  \par
  377     color++;        /* next color for next slice        */\par
  378     if(!*color) color=colortable;/* start over if all colors used   */\par
  379     \}\par
  380 \par
  381                     /* the closing circle and middle point  */\par
  382                 /* only, if LINEWIDTH!=default  */\par
  383     if(LINEWIDTH!=-1)\par
  384     \{\par
  385                 /* add %5 to compensate for arc obstrution*/\par
  386         pl_flinewidth(LINEWIDTH*1.2);\par
  387 \par
  388     pl_filltype(0);\par
  389     pl_fcircle(0.,0.,r);    \par
  390 \par
  391     pl_colorname(LINECOLOR);\par
  392     pl_filltype(1);\par
  393     pl_fpoint(0,0); \par
  394     \}\par
  395                     \par
  396     pl_restorestate();\par
  397 \}\par
  398 \par
  399 /* and now for the text     */\par
  400 \{\par
  401     double distance,angle=0,place;\par
  402     double r=radius+text_distance;/* radius of circle where text is placed*/\par
  403     char h,v;\par
  404     pl_savestate();\par
  405 \par
  406     for(t=0;t<n_slices;t++) \par
  407     \{\par
  408         distance=(slices[t]->value/sum)*360.;\par
  409                     /* let us calculate the position ...    */\par
  410     place=angle+0.5*distance;\par
  411                 /* and the alignment            */\par
  412     if(place<180)\par
  413         v='b';\par
  414     else\par
  415         v='t';\par
  416     if(place<90 || place>270)\par
  417         h='l';\par
  418     else\par
  419         h='r';\par
  420                 /* plot now!                */\par
  421     pl_fmove(XY(r,place));\par
  422     pl_alabel(h,v,slices[t]->text);\par
  423     \par
  424     angle+=distance;\par
  425     \}\par
  426                     \par
  427     pl_restorestate();\par
  428 \}\par
  429 \par
  430 \par
  431     \par
  432      \} /* end of is Pie */\par
  433 else \par
  434      \{  /* next part plots bars , chris */\par
  435     if(title || xtext || mytext)\par
  436       \{\par
  437          text_space = -2.0 - text_distance ;\par
  438       \}\par
  439     else\par
  440       \{\par
  441          text_space = -1.0 - text_distance ;         \par
  442       \}\par
  443      /* x0, y0, x1 y1 but it has to be square for the fonts*/\par
  444     return_value= pl_fspace(text_space / radius, \par
  445                 text_space / radius, \par
  446                 (10.0 - text_space) / radius, \par
  447                 (10.0 - text_space) / radius );\par
  448 if(return_value)\par
  449 \{   fprintf(stderr,"fspace returned %d!\\n",return_value);   \}\par
  450 \par
  451 \par
  452 /* we should be ready to plot bars, now! */\par
  453 \par
  454 \par
  455  \par
  456 /* plot title if there is one */\par
  457 if(title&&*title)\par
  458 \{\par
  459         pl_ffontsize (0.5);\par
  460         pl_fmove( 5, 11 ) ;\par
  461     pl_alabel('c','c',title); /* centered */\par
  462 \}\par
  463 /* plot X axis title if there is one */\par
  464 if(xtext&&*xtext)\par
  465 \{\par
  466         pl_ffontsize (0.5);\par
  467         pl_fmove( 5, 0.7 * text_space ) ;\par
  468     pl_alabel('c','c',xtext); /* cnetered */\par
  469 \}\par
  470 /* plot Y axis title if there is one */\par
  471 if(mytext&&*mytext)\par
  472 \{\par
  473         pl_ffontsize (0.5);\par
  474         pl_fmove( 0.8 * text_space, 6 ) ;\par
  475         pl_ftextangle (90);\par
  476     pl_alabel('c','c',mytext); \par
  477         pl_ftextangle (0); \par
  478 \}\par
  479 /* find y max */\par
  480     \par
  481     while ( ymax < slice_max )\par
  482        \{\par
  483       ymax = ymax * nf [n] ;\par
  484       n ++ ;\par
  485       if ( nf[n] ) n = 0 ;\par
  486        \}\par
  487     pl_line ( 0,0,0, 10.0 *  ymax / slice_max  );\par
  488 /* plot Y axis */\par
  489     while ( ystep < ymax ) \par
  490      \{\par
  491     pl_fline ( -0.3, 10 * (double) ystep/ slice_max ,0.0, 10 * ystep / slice_max );\par
  492     pl_fmove ( 0.3 * text_space , 10 * (double) ystep / slice_max  );\par
  493     sprintf ( buffer, "%d", ystep );\par
  494     pl_alabel ( 'r','c', buffer );  \par
  495     ystep = ystep + ymax / 10;\par
  496     if (ystep < 1 ) ystep ++ ;\par
  497      \}  \par
  498 \par
  499 \par
  500      pl_pencolorname(LINECOLOR);\par
  501 \par
  502 /* and now for the bars     */\par
  503 \{\par
  504 \par
  505     char **color=colortable;\par
  506 \par
  507     pl_savestate();\par
  508     pl_joinmod("round");\par
  509     \par
  510     pl_filltype(1);\par
  511     pl_flinewidth(LINEWIDTH);\par
  512     pl_pencolorname(LINECOLOR);\par
  513     for(t=0;t<n_slices;t++)\par
  514 \par
  515     \{\par
  516         pl_fillcolorname(*color);\par
  517         pl_fbox (10.0 * (double)(t)/(double)(n_slices),\par
  518          0,\par
  519          10.0 * (double)(t+1)/(double)(n_slices),\par
  520          10 * slices[t]->value/slice_max );\par
  521     color++;        /* next color for next slice        */\par
  522     if(!*color) color=colortable;/* start over if all colors used   */\par
  523     \} /* end of for each slice */\par
  524 \par
  525     pl_restorestate();\par
  526 \}\par
  527 \par
  528 /* and now for the text     */\par
  529 \{\par
  530     char just ;\par
  531     just = 'c';\par
  532    \par
  533     pl_savestate();\par
  534     pl_ffontsize (0.4);\par
  535     if (n_slices > 5)\par
  536      \{\par
  537     pl_ftextangle (90); /* degrees */\par
  538     just = 'r' ;\par
  539      \}\par
  540     for(t=0;t<n_slices;t++) \par
  541     \{\par
  542 /* plot now!                */\par
  543     pl_fmove(10.0 * (double)(t+0.5)/(double)(n_slices),\par
  544          0.3 * text_space );\par
  545     pl_alabel(just, 'c' ,slices[t]->text);\par
  546     \}\par
  547     pl_restorestate();\par
  548 \}\par
  549      \} /* end of is ! Pie */\par
  550 \par
  551                 /* end a plot sesssion          */\par
  552 return_value= pl_closepl();\par
  553 if(return_value<0)\par
  554 \{   fprintf(stderr,"The plotter could not be closed.\\n");\par
  555     /* no exit, because we try to delete the plotter        */\par
  556 \}\par
  557                 \par
  558 /* need to select a different plotter in order to deleter our       */\par
  559 return_value=pl_selectpl(0);\par
  560 if(return_value<0)\par
  561 \{   fprintf(stderr,"Default Plotter could not be selected!\\n");\par
  562 \}\par
  563 \par
  564 return_value=pl_deletepl (handle);/* clean up by deleting used plotter  */\par
  565 if(return_value<0)\par
  566 \{   fprintf(stderr,"Selected Plotter could not be deleted!\\n");\par
  567 \}\par
  568 \par
  569             \par
  570 return 0;\par
  571 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "ascii__chart__ps_8c_a3c04138a5bfe5d72780bb7e82a18e627_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v print_version\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:print_version}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void print_version (FILE *  {\i file})}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 73} of file {\b ascii_chart_ps.c}.}\par
{
References {\b VERSION}.}\par
{
Referenced by {\b process_arguments()}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    74 \{\par
   75              fprintf(file,"ascii_chart version " VERSION "\\n"); \par
   76              fprintf(file,"Copyright (C) 1998 - 2020" \par
   77         "by Bernhard Reiter & Chris Elliott, \\n"\par
   78         "updated by Francesco Lazzarotto. \\n"\par
   79                     "The GNU GENERAL PUBLIC LICENSE v3 applies. "\par
   80                         "Absolutly No Warranty!\\n");\par
   81 #ifdef DEBUG\par
   82              fprintf(file,"compiled with option: DEBUG\\n"); \par
   83 #endif\par
   84 \}\par
}
}
{\xe \v process_arguments\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:process_arguments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void process_arguments (int  {\i argc}, char **  {\i argv}, char **  {\i display_type}, char **  {\i title}, char **  {\i xtext}, char **  {\i ytext}, int *  {\i isPie}, double *  {\i radius}, double *  {\i text_distance}, char *  {\i colortable}[])}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 578} of file {\b ascii_chart_ps.c}.}\par
{
References {\b colortable}, {\b print_version()}, and {\b progname}.}\par
{
Referenced by {\b main()}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   581 \{\par
  582 /* well, we do not have the gnu getopt long here. :-( \par
  583  * so i use getopt for now\par
  584  */\par
  585           int c;        \par
  586           extern char *optarg;\par
  587       /* optint,opterr,optopt relate to getopt(),see manpage*/\par
  588       /* but we do not use them so far          */\par
  589           /* extern int optind,opterr,optopt; */ \par
  590           int errflg = 0;\par
  591           int show_usage=0;\par
  592           int show_version=0;\par
  593       int specified_display_type=0;\par
  594       char **help;  /* will help splitting the colornames   */\par
  595       char * arg;   /* one string argument          */\par
  596 *isPie = 0 ; /* ie do a bar chart */\par
  597 progname=argv[0];   /* fill the only global variable    */\par
  598 \par
  599           while ((c = getopt(argc, argv, "Vt:T:r:d:C:h:X:Y:P")) != EOF)\par
  600                switch (c) \{\par
  601 /* chris did some debugging here */\par
  602         case 't':\par
  603 #ifdef DEBUG\par
  604         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  605 #endif        \par
  606                          *title=xstrdup(optarg);\par
  607 #ifdef DEBUG\par
  608           fprintf (stderr, "OK \\n");\par
  609 #endif        \par
  610           break;\par
  611         case 'X':\par
  612 #ifdef DEBUG\par
  613         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  614 #endif        \par
  615                          *xtext=xstrdup(optarg);\par
  616 #ifdef DEBUG\par
  617           fprintf (stderr, "OK \\n");\par
  618 #endif        \par
  619           break;\par
  620         case 'Y':\par
  621 #ifdef DEBUG\par
  622         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  623 #endif        \par
  624                          *ytext=xstrdup(optarg);\par
  625 #ifdef DEBUG\par
  626           fprintf (stderr, "OK \\n");\par
  627 #endif        \par
  628           break;\par
  629           \par
  630                case 'T':\par
  631 #ifdef DEBUG\par
  632         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  633 #endif        \par
  634                     if (specified_display_type)\par
  635                          errflg++;\par
  636                     else \{\par
  637                 specified_display_type++;\par
  638                 *display_type = xstrdup(optarg);\par
  639             \}\par
  640 #ifdef DEBUG\par
  641           fprintf (stderr, "OK \\n");\par
  642 #endif        \par
  643           break;\par
  644            case 'P':\par
  645 #ifdef DEBUG\par
  646         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  647 #endif        \par
  648                 *isPie = 1 ;\par
  649 /* ie try to plot as pie chart */                   \par
  650 #ifdef DEBUG\par
  651         fprintf(stderr," OK \\n");\par
  652 #endif        \par
  653           break;\par
  654 \par
  655         case 'r':\par
  656 #ifdef DEBUG\par
  657         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  658 #endif        \par
  659                 *radius=atof(optarg);\par
  660                 if(*radius<0.1||*radius>1.2)\par
  661                 errflg++;\par
  662 #ifdef DEBUG\par
  663           fprintf (stderr, "OK \\n");\par
  664 #endif        \par
  665           break;\par
  666             \par
  667            case 'd':\par
  668 #ifdef DEBUG\par
  669         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  670 #endif        \par
  671                 *text_distance=atof(optarg);\par
  672                 if(*text_distance<(-2.0)||*text_distance>1.2)\par
  673                 errflg++;\par
  674             /* we have a second check after processing all options*/\par
  675 #ifdef DEBUG\par
  676           fprintf (stderr, "OK \\n");\par
  677 #endif        \par
  678           break;\par
  679             \par
  680            case 'C':\par
  681 #ifdef DEBUG\par
  682         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  683 #endif        \par
  684             help=colortable;\par
  685             arg=xstrdup(optarg);\par
  686             *help++=strtok(arg,",\\0");\par
  687             if(!*help)\par
  688                 errflg++;\par
  689             else\par
  690                 while((*(help++)=strtok(NULL,",\\0")));\par
  691 #ifdef DEBUG\par
  692           fprintf (stderr, "OK \\n");\par
  693 #endif        \par
  694           break;\par
  695             \par
  696                case 'V':\par
  697 #ifdef DEBUG\par
  698         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  699 #endif        \par
  700                     if (show_version)\par
  701                          errflg++;\par
  702                     else\par
  703                          show_version++;\par
  704 #ifdef DEBUG\par
  705           fprintf (stderr, "OK \\n");\par
  706 #endif        \par
  707           break;\par
  708                case 'h':\par
  709 #ifdef DEBUG\par
  710         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  711 #endif        \par
  712                     if (show_usage)\par
  713                          errflg++;\par
  714                     else\par
  715                          show_usage++;\par
  716 #ifdef DEBUG\par
  717           fprintf (stderr, "OK \\n");\par
  718 #endif        \par
  719           break;\par
  720                case '?':\par
  721 #ifdef DEBUG\par
  722         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  723 #endif        \par
  724                     errflg++;\par
  725                \}\par
  726                     /* check if text_distance is reasonable */\par
  727       if(*text_distance< (-*radius)) errflg++;\par
  728       if (! (*isPie) ) *radius = sqrt ( *radius ) ; /* for bar charts only */\par
  729                                            /* or else the size gets too small to see */\par
  730           if (errflg) \{ \par
  731                fprintf(stderr, "parameters were bad!\\n");\par
  732                show_usage++;\par
  733           \}\par
  734           if(show_version)\par
  735           \{\par
  736              print_version(stdout); \par
  737              exit(1);\par
  738           \}\par
  739           if(show_usage)\par
  740           \{ FILE *f=stdout;\par
  741         if(errflg)\par
  742                     f=stderr;\par
  743         else    f=stdout;\par
  744          print_version(f);\par
  745         \par
  746              fprintf(f,"usage: %s [options]\\n",progname); \par
  747              fprintf(f,"\\t the stdin is read once.\\n");\par
  748              fprintf(f,"\\t options are:\\n"\\\par
  749                     "\\t\\t-P Use Pie rather than Bar chart ( not -X -Y )\\n"\\\par
  750                     "\\t\\t-t Title\\tset \\"Title\\" as chart title\\n"\\\par
  751                     "\\t\\t-X XTitle\\tset \\"XTitle\\" as barchart X axis title\\n"\\\par
  752                     "\\t\\t-Y YTitle\\tset \\"YTitle\\" as barchart Y axis title\\n"\\\par
  753                     "\\t\\t-T Display-Type\\tone of "\\\par
  754                 "X, ps, fig, hpgl, tek, meta, ai, pnm, gif\\n"\\\par
  755             "\\t\\t\\t\\t(or whatever your libplot version supports)\\n"\\\par
  756             "\\t\\t\\t\\t(meta is the default)\\n"\\\par
  757                     "\\t\\t-r size of chart\\tfloat out of [0.1;1.2] default:0.8\\n"\\\par
  758                     "\\t\\t-d textdistance around chart \\tfloat out of "\\\par
  759                         "[-radius;1.2] default:0.0\\n"\\\par
  760             "\\t\\t-C colornames\\tcomma separated list of colornames\\n"\\\par
  761             "\\t\\t\\t\\t(see valid names in color.txt of plotutils doc.)\\n"\\\par
  762                     "\\t\\t-h\\t\\tprint this help and exit\\n"\\\par
  763                     "\\t\\t-V\\t\\tprint version and exit\\n"\\\par
  764                     );\par
  765              \par
  766              exit(1);\par
  767           \}\par
  768 \par
  769 /* Everything is fine with the options now ... */\par
  770 \}\par
}
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "ascii__chart__ps_8c_a219229f3ebcf2131152ab1c224d926b4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v read_stdin\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:read_stdin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void read_stdin (int *  {\i n_slices}, struct {\b slice} *  {\i slices}[MAXSLICES])}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 773} of file {\b ascii_chart_ps.c}.}\par
{
References {\b COMMENTCHAR}, {\b LINE_BUFSIZ}, {\b progname}, {\b slice::text}, and {\b slice::value}.}\par
{
Referenced by {\b main()}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   774 \{\par
  775 char line [LINE_BUFSIZ];        /* input line buffer            */\par
  776 \par
  777 /* So, let us read the standardinput */\par
  778 while( !(feof(stdin) || ferror(stdin)) )\par
  779 \{\par
  780 char *c;            /* string return from fgets     */\par
  781 struct slice * aslice;      /* freshly filled slice-structure   */\par
  782 int r;              /* help variable for scanning       */\par
  783 char *s,*t;         /* help variables for scanning      */\par
  784 \par
  785     c=fgets(line,LINE_BUFSIZ,stdin);\par
  786     if(!c) continue;    /* encountered error of eof     */\par
  787     if(line[strlen(line)-1]!='\\n')\par
  788     \{\par
  789         fprintf(stderr,"line was too long!\\n");\par
  790         exit(2);\par
  791     \}\par
  792                 /* strip newline */\par
  793     line[strlen(line)-1]='\\0';\par
  794                 /* strip carridge return, if there is one*/\par
  795     if(line[strlen(line)-1]=='\\r') \par
  796         line[strlen(line)-1]='\\0';\par
  797     \par
  798                 /* Skip empty lines or lines beginning  \par
  799                  * with COMMENTCHAR         */\par
  800     if(!(line[0]==COMMENTCHAR || !(line) || strlen(line)==0))\par
  801     \{\par
  802 #ifdef DEBUG\par
  803         fprintf(stderr,"Scanning line: %s\\n",line);\par
  804 #endif\par
  805         aslice=malloc(sizeof(struct slice));\par
  806         if(!aslice)\par
  807             perror(progname),exit(10);\par
  808             \par
  809             \par
  810                 /* scanning the last part\par
  811                  * after a tab or space as number   */\par
  812                  \par
  813                 /* delete trailing tabs and spaces  */\par
  814         r=strlen(line);\par
  815         while(r>0 && (line[r-1]==' ' || line[r-1]=='\\t') )\par
  816             line[r---1]='\\0';\par
  817                 /* scan for last tab or space       */\par
  818         s=strrchr(line,' ');\par
  819         t=strrchr(line,'\\t');\par
  820         s=(s>t?s:t);    /* which is the last white-space?   */\par
  821             \par
  822                 /*use full string,if no whitespace found\par
  823                 else copy text up to whitespace\par
  824                 and get enough memory           */\par
  825         if(s==NULL) \par
  826         \{\par
  827             if(!(aslice->text=malloc(1))) \par
  828                 perror(progname),exit(10);\par
  829             aslice->text[0]='\\0'; \par
  830             s=line;\par
  831         \} else\par
  832         \{   \par
  833             if(!(aslice->text=malloc(strlen(line)-strlen(s)+1))) \par
  834                 perror(progname),exit(10);\par
  835             strncpy(aslice->text,line, strlen(line)-strlen(s));\par
  836                 /*some systems don`t terminate target \par
  837                 string in strncpy, so we have to do it  */\par
  838             aslice->text[strlen(line)-strlen(s)]='\\0';\par
  839         \}\par
  840         \par
  841                 /* scan last string for number      */\par
  842         r=sscanf(s,"%lf",&aslice->value);\par
  843         if(r!=1)\par
  844             fprintf(stderr,"number in line couldn`t be scanned\\n"),\par
  845                 exit(8);\par
  846         \par
  847         if(*n_slices>=MAXSLICES)\par
  848             fprintf(stderr,"too many slices\\n"),exit(8);\par
  849             \par
  850         slices[(*n_slices)++]=aslice;\par
  851     \}\par
  852 \}\par
  853 \par
  854 if(ferror(stdin))\par
  855 \{\par
  856     perror(progname);\par
  857     exit(5);\par
  858 \}\par
  859 \par
  860 #ifdef DEBUG\par
  861 fprintf(stderr,"Read %d slices!\\n",*n_slices);\par
  862 #endif \par
  863 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v colortable\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:colortable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* colortable[{\b MAXSLICES}]}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{  \par
   "red",  "blue",   "green", "yellow", \par
 "firebrick",  "aliceblue","greenyellow",  "wheat",\par
NULL\par
\}\par
}
{
Definition at line {\b 187} of file {\b ascii_chart_ps.c}.}\par
{
Referenced by {\b main()}, and {\b process_arguments()}.}\par
}
{\xe \v progname\:ascii_chart_ps.c}
{\xe \v ascii_chart_ps.c\:progname}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* progname}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 220} of file {\b ascii_chart_ps.c}.}\par
{
Referenced by {\b process_arguments()}, and {\b read_stdin()}.}\par
}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ascii_chart_ps.c\par \pard\plain 
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     1 /* code modified Sept 1999 to produce bar charts as well as pies\par
    2  * Copyright (C) 1999 Chris Elliott ( cje2@york.ac.uk ) and Bernhard Reiter \par
    3  * GNU public licence still applies\par
    4  * -X labels X axis of bar chart -Y labels Y axis of chart\par
    5  * \par
    6  * v0.05 bug with -Y often giving a seg fault traced to fault on optarg list\par
    7  * v0.1 -r adius and -d istance options control size in  bar chart\par
    8  */\par
    9 \par
   10 /* Bernhard Reiter  Fri Oct 10 20:07:12 MET DST 1997\par
   11  * $Id: piechart.c,v 1.11 1999/04/03 10:26:32 breiter Exp $\par
   12  *\par
   13  * Copyright (C) 1997,1998 by Bernhard Reiter \par
   14  * \par
   15  *    This program is free software; you can redistribute it and/or\par
   16  *   modify it under the terms of the GNU General Public License\par
   17  *   as published by the Free Software Foundation; either version 2\par
   18  *   of the License, or (at your option) any later version.\par
   19  *\par
   20  *   This program is distributed in the hope that it will be useful,\par
   21  *   but WITHOUT ANY WARRANTY; without even the implied warranty of\par
   22  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\par
   23  *   GNU General Public License for more details.\par
   24  *\par
   25  *   You should have received a copy of the GNU General Public License\par
   26  *   along with this program; if not, write to the Free Software\par
   27  *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\par
   28  *\par
   29  *  \par
   30  *  Creates bar or piechart, must be linked with a libplot library\par
   31  *  reads ascii input file from stdin.\par
   32  *\par
   33  *  format: one slice per line. every trailing tab and space will\par
   34  *      be ignored. The string after the last tab or space is\par
   35  *      will be scanned as value. The beginnign is the label-text.\par
   36  *      Empty lines and lines starting with "#" are ignored\par
   37  *\par
   38  *  TODO: many improvements possible.\par
   39  *      - make stuff more dynamic (input linelength and max # of slices)\par
   40  *      - better handling of progname\par
   41  *      - move much stuff into command line options\par
   42  *      e.g.    \par
   43  *          + fonts\par
   44  *          + rotation of the pie\par
   45  *      - use getopt_long\par
   46  *      - make better assumptions on how to place the labels\par
   47  *      - add printing percentage numbers and values;as options\par
   48  *      - special handling of very small slices\par
   49  *      - make multi line labels possible\par
   50  *      - multi-line titles?\par
   51  *      - does every system have xstrdup(), strncpy()?\par
   52  *      - \par
   53  *      ...\par
   54  *\par
   55  *  THANKS: To "Martin J. Evans" <martin@mjedev.demon.co.uk>\par
   56  *      for pointing out that some systems do not terminate\par
   57  *      the target string after strncpy().\par
   58  *      \par
   59  *      Jan-Oliver Wagner <jwagner@usf.uni-osnabrueck.de>\par
   60  *      created first version ito work with gnuplotutils-2.2.\par
   61  */\par
   62 #include "constants.h"\par
   63 #include <math.h>\par
   64 #include <stdio.h>\par
   65 #include <plot.h>\par
   66 #include <libcommon.h>\par
   67 \par
   68 #define min(X, Y)  ((X) < (Y) ? (X) : (Y))\par
   69 #define max(X, Y)  ((X) > (Y) ? (X) : (Y))\par
   70 \par
   71 \par
   72 #define VERSION "1.00 "\par
   73 void print_version(FILE *file)\par
   74 \{\par
   75              fprintf(file,"ascii_chart version " VERSION "\\n"); \par
   76              fprintf(file,"Copyright (C) 1998 - 2020" \par
   77         "by Bernhard Reiter & Chris Elliott, \\n"\par
   78         "updated by Francesco Lazzarotto. \\n"\par
   79                     "The GNU GENERAL PUBLIC LICENSE v3 applies. "\par
   80                         "Absolutly No Warranty!\\n");\par
   81 #ifdef DEBUG\par
   82              fprintf(file,"compiled with option: DEBUG\\n"); \par
   83 #endif\par
   84 \}\par
   85 \par
   86 /*\par
   87  * $Log: piechart.c,v $\par
   88  * Revision 1.11  1999/04/03  10:26:32  breiter\par
   89  * adapted to plotutils-2.2: added pl_ to all function calls\par
   90  * adjusted help text\par
   91  * more return values are checked now, as the function provide more of them\par
   92  * end circle and middle point are only drawn if LINEWIDTH is not default\par
   93  * changed constant name LINEWIDTH_LINES -> LINEWIDTH\par
   94  * end circle and middle point LINEWIDTH is multiplied with a factor(~1.2) now\par
   95  * extra external variables for getopt() are commented out\par
   96  *\par
   97  * Revision 1.10  1998/07/28  13:41:54  breiter\par
   98  * - Terminating strncpy()ed string now. Thanks to "Martin J. Evans"\par
   99  * for reporting this problem.\par
  100  * - Removed hard limit on label-size.\par
  101  * - Changed inputline buffersize to a new constant defined as LINE_BUFSIZ.\par
  102  * - Cleaned up some comments.\par
  103  * version number incremented to 0.8\par
  104  *\par
  105  * Revision 1.9  1998/07/07  23:44:26  breiter\par
  106  * added -C option for specifing colors\par
  107  * version number is 0.7 now.\par
  108  *\par
  109  * Revision 1.8  1998/07/07  17:04:40  breiter\par
  110  * major improvements:\par
  111  * - more structure: moves code into functions: process_arguments(),read_stdin()\par
  112  * - new scanning -> multi word labels are possible now\par
  113  * - two new options: -r radius and -d text distance\par
  114  * - errmsgs and usage are printed to stderr now, but to stdout, wenn requested\par
  115  * - fixed debug output typo\par
  116  *\par
  117  * Revision 1.7  1998/01/31  16:13:02  breiter\par
  118  * changed fill() -> filltype() as fill() is only temporarily supported\par
  119  *\par
  120  * Revision 1.6  1998/01/31  16:05:40  breiter\par
  121  * using a path to draw one slice now. This is far simpler.\par
  122  * No need for LINEWIDTH_FILL anymore.\par
  123  *\par
  124  * Revision 1.5  1998/01/30  16:06:37  breiter\par
  125  * adapted for use with libplot from plotutils-2.0\par
  126  * added +T display-type commandline option therefore.\par
  127  *\par
  128  * Revision 1.4  1997/10/11  17:19:14  breiter\par
  129  * cosmetic changes. version information enhanced.\par
  130  *\par
  131  * Revision 1.3  1997/10/11  16:31:56  breiter\par
  132  * version information enhanced.\par
  133  *\par
  134  * Revision 1.2  1997/10/11  16:09:15  breiter\par
  135  * bug fixes. small improvements. userspace is always square now.\par
  136  *\par
  137  * Revision 1.1  1997/10/11  15:07:27  breiter\par
  138  * Initial revision\par
  139  *\par
  140  */\par
  141 \par
  142 #include <stdlib.h>\par
  143 #include <math.h>\par
  144 #include <string.h>     /* for xstrdup() */\par
  145      \par
  146 /* this program used getopt and relys on that it is included in the \par
  147  * stdlib. I wanted to use getopt_long from Gnu, but it is not included\par
  148  * in the clib i have here. So it is still left TODO.\par
  149  */\par
  150 \par
  151 /*******************************************************************************\par
  152  * Configurations -- change, what you like\par
  153  *  If time permits some stuff could be influenced by command line options\par
  154  ******************************************************************************/\par
  155 \par
  156 /*  Color in which the separating lines and the circle are drawn\par
  157  */\par
  158 #define LINECOLOR "black"\par
  159 \par
  160 /* LINEWIDTH is for the separating lines and the arcs\par
  161  * if closing circle and middle point will be drawn, a factor will be applied\par
  162  * -1 means default ; 0.02 might be a usefull value\par
  163  */\par
  164 #define LINEWIDTH -1\par
  165 \par
  166 /* Some hardcoded limits:\par
  167  * the max number of slices (^=MAXSLICES).\par
  168  * LINE_BUFSIZ is the maxmumlength of input-lines.\par
  169  *(You see, how lasy i was. I was not using some object orientated language\par
  170  *  like objective-c and left all the neat dynamic string handling for\par
  171  *  the interested hacker and or some version in the future.)\par
  172  */\par
  173 #define MAXSLICES 65\par
  174 #define LINE_BUFSIZ 256\par
  175 \par
  176 /* if an input line starts with this character, it is ignored.      */\par
  177 #define COMMENTCHAR '#'\par
  178 \par
  179 /* Colors the slices are getting filled with.\par
  180  * the color names are feed into the libplot functions.\par
  181  * The plotutils distribution contains a file doc/colors.txt which lists the\par
  182  * recogized names.\par
  183  *\par
  184  * if the nullpointer is reached the color pointer is resetted starting\par
  185  * with the first color again.\par
  186  */\par
  187 char *colortable[MAXSLICES] = \{  /* colors changed by chris */\par
  188    "red",  "blue",   "green", "yellow", \par
  189  "firebrick",  "aliceblue","greenyellow",  "wheat",\par
  190 NULL\par
  191 \};\par
  192 \par
  193 \par
  194 /*******************************************************************************\par
  195  * Beware: This following code is for hackers only.\par
  196  *  ( Yeah, it is not THAT bad, you can risk a look, if you know some C ..)\par
  197  ******************************************************************************/\par
  198 \par
  199 /* Program structure outline:\par
  200  *  - get all options \par
  201  *  - read all input data (only from stdin so far)\par
  202  *  - print\par
  203  *      + init stuff\par
  204  *      + print title\par
  205  *      + print color part for slices\par
  206  *      + print separating lines and circle\par
  207  *      + print labels\par
  208  *      + clean up stuff\par
  209  */\par
  210 \par
  211 \par
  212 /* A nice structure, we will fill some of it, when we read the input.\par
  213  */\par
  214 struct slice \{\par
  215     char *text;     /* label for the slice          */\par
  216     double value;       /* value for the slice          */\par
  217 \};\par
  218 \par
  219 /* one global variable. It is needed everywhere..               */\par
  220 char * progname;        /*  for printing errors out     */\par
  221 \par
  222 \par
  223 /* declarations of functions defined after main()           \par
  224  */\par
  225 void process_arguments(int argc, char **argv, \par
  226     char **display_type, char ** title, char ** xtext, char ** ytext,\par
  227     int * isPie, double *radius, double *text_distance, char *colortable[]);\par
  228 void read_stdin(int *n_slices, struct slice *slices[MAXSLICES]);\par
  229 \par
  230 \par
  231 /* Attention: Main Progam to be started.... :)              */\par
  232 \par
  233 int main(int argc, char **argv)\par
  234 \{\par
  235    char * title="myPlot";       /* Title of the chart           */\par
  236    char * xtext="x_axis";       /* X axis Title of the chart            */\par
  237    char * mytext="y_axis";      /* Y axis Title of the chart            */\par
  238 int return_value;       /* return value for libplot calls.  */\par
  239 char *display_type = "ps";  /* default libplot output format    */\par
  240 int handle;         /* handle for open plotter      */\par
  241 \par
  242 struct slice *slices[MAXSLICES];/* the array of slices          */\par
  243 int n_slices=0;         /* number of slices in slices[] ;)  */\par
  244 int t;              /* loop var(s)              */\par
  245 double slice_max, sum;      /* max and sum of all slice values chris        */\par
  246 int neg_flag  ;   \par
  247                                 /* check all values > 0 chris */\par
  248 double radius=0.8;      /* radius of the circle in plot coords  */\par
  249 double text_distance=0;     /* distance of text from circle     */\par
  250 int isPie = 0 ;                 /* switch mode; chris */ \par
  251 \par
  252 double text_space  ;   \par
  253    \par
  254 /* vars for ymax */\par
  255    char buffer [55] ;    \par
  256    double ymax ;\par
  257     int ystep ;\par
  258     int nf [4] = \{ 2,5,2,0 \};\par
  259     int n = 1 ;\par
  260     ymax = 1.0 ;\par
  261     ystep = 0 ;\par
  262     \par
  263     \par
  264 process_arguments(argc,argv,\par
  265     &display_type,&title,&xtext,&mytext,&isPie,&radius,&text_distance,colortable);\par
  266 \par
  267 read_stdin(&n_slices,slices);\par
  268 \par
  269 /* Let us find the sum and  max and check for negative values */\par
  270 /* code added to by chris */   \par
  271 sum = 0 ;\par
  272 slice_max=1.;\par
  273 neg_flag = 0 ;   \par
  274    \par
  275 for(t=0;t<n_slices;t++)\par
  276      \{\par
  277      sum+=slices[t]->value;\par
  278      slice_max = max (slice_max,slices[t]->value) ;\par
  279      if ( slices [t]->value < 0 ) neg_flag ++ ; \par
  280      \}\par
  281 \par
  282 if ( neg_flag )\par
  283      \{\par
  284      fprintf(stderr,"Some data were apparently less than zero. \\nThis version of the program does not plot negative values.\\n");\par
  285      exit(1);\par
  286      \}\par
  287 /* initialising one plot session    */\par
  288                 /* specify type of plotter      */\par
  289 handle=pl_newpl(display_type, NULL, stdout, stderr);\par
  290 if(handle<0)\par
  291 \{   fprintf(stderr,"The plotter could not be created.\\n");\par
  292     exit(1);\par
  293 \}\par
  294 \par
  295 return_value=pl_selectpl(handle);          \par
  296 if(return_value<0)\par
  297 \{   fprintf(stderr,"The plotter does not exist or could not be selected.\\n");\par
  298     exit(1);\par
  299 \}\par
  300 \par
  301 return_value= pl_openpl();\par
  302 if(return_value<0)\par
  303 \{   fprintf(stderr,"The selected plotter could not be opened!\\n");\par
  304     exit(1);\par
  305 \}\par
  306 \par
  307 /* now decide to plot bar or pie */\par
  308 if ( isPie ) \par
  309      \{\par
  310                 /* creating your user coordinates   */\par
  311 if(title)\par
  312     return_value= pl_fspace(-1.4,-1.4,1.4,1.4);\par
  313 else\par
  314     return_value= pl_fspace(-1.2,-1.2,1.2,1.2);\par
  315 if(return_value)\par
  316 \{   fprintf(stderr,"fspace returned %d!\\n",return_value);   \}\par
  317 \par
  318 \par
  319 /* we should be ready to plot pie, now! */\par
  320 \par
  321 \par
  322 \par
  323                 /* i like to think in degrees.      */\par
  324 #define X(radius,angle) (cos(angle)*(radius))\par
  325 #define Y(radius,angle) (sin(angle)*(radius))\par
  326 \par
  327 #define RAD(angle) (((angle)/180.)*M_PI)\par
  328 \par
  329 #define XY(radius,angle) (X((radius),RAD(angle))),(Y((radius),RAD(angle)))\par
  330 \par
  331 /* plot title if there is one */\par
  332 if(title&&*title)\par
  333 \{\par
  334     pl_fmove(0,radius+text_distance+0.2);\par
  335     pl_alabel('c','b',title);\par
  336 \}\par
  337 \par
  338 pl_pencolorname(LINECOLOR);\par
  339 \par
  340 /* and now for the slices       */\par
  341 \{\par
  342     double distance,angle=0;\par
  343     char **color=colortable;\par
  344     double r=radius;            /*the radius of the slice circle*/\par
  345 \par
  346     pl_savestate();\par
  347     pl_joinmod("round");\par
  348 \par
  349                 /* drawing the slices           */\par
  350     \par
  351     pl_filltype(1);\par
  352     pl_flinewidth(LINEWIDTH);\par
  353     pl_pencolorname(LINECOLOR);\par
  354     for(t=0;t<n_slices;t++)\par
  355                 /* draw one path for every slice    */\par
  356     \{\par
  357         distance=(slices[t]->value/sum)*360.;\par
  358         pl_fillcolorname(*color);\par
  359                 \par
  360     pl_fmove(0,0);      /* start at center..            */\par
  361     pl_fcont(XY(r,angle));  \par
  362         if(distance>179)\par
  363         \{           /* we need to draw a semicircle first   */\par
  364                 /* we have to be sure to draw \par
  365                    counterclockwise (180 wouldn`t work \par
  366                    in all cases)            */\par
  367         pl_farc(0,0,XY(r,angle),XY(r,angle+179)); \par
  368         angle+=179; \par
  369         distance-=179;\par
  370         \}\par
  371     pl_farc(0,0,XY(r,angle),XY(r,angle+distance));\par
  372     pl_fcont(0,0);      /* return to center         */\par
  373     pl_endpath();       /* not really necessary, but intuitive  */\par
  374     \par
  375     angle+=distance;    /* log fraction of circle already drawn */\par
  376                  \par
  377     color++;        /* next color for next slice        */\par
  378     if(!*color) color=colortable;/* start over if all colors used   */\par
  379     \}\par
  380 \par
  381                     /* the closing circle and middle point  */\par
  382                 /* only, if LINEWIDTH!=default  */\par
  383     if(LINEWIDTH!=-1)\par
  384     \{\par
  385                 /* add %5 to compensate for arc obstrution*/\par
  386         pl_flinewidth(LINEWIDTH*1.2);\par
  387 \par
  388     pl_filltype(0);\par
  389     pl_fcircle(0.,0.,r);    \par
  390 \par
  391     pl_colorname(LINECOLOR);\par
  392     pl_filltype(1);\par
  393     pl_fpoint(0,0); \par
  394     \}\par
  395                     \par
  396     pl_restorestate();\par
  397 \}\par
  398 \par
  399 /* and now for the text     */\par
  400 \{\par
  401     double distance,angle=0,place;\par
  402     double r=radius+text_distance;/* radius of circle where text is placed*/\par
  403     char h,v;\par
  404     pl_savestate();\par
  405 \par
  406     for(t=0;t<n_slices;t++) \par
  407     \{\par
  408         distance=(slices[t]->value/sum)*360.;\par
  409                     /* let us calculate the position ...    */\par
  410     place=angle+0.5*distance;\par
  411                 /* and the alignment            */\par
  412     if(place<180)\par
  413         v='b';\par
  414     else\par
  415         v='t';\par
  416     if(place<90 || place>270)\par
  417         h='l';\par
  418     else\par
  419         h='r';\par
  420                 /* plot now!                */\par
  421     pl_fmove(XY(r,place));\par
  422     pl_alabel(h,v,slices[t]->text);\par
  423     \par
  424     angle+=distance;\par
  425     \}\par
  426                     \par
  427     pl_restorestate();\par
  428 \}\par
  429 \par
  430 \par
  431     \par
  432      \} /* end of is Pie */\par
  433 else \par
  434      \{  /* next part plots bars , chris */\par
  435     if(title || xtext || mytext)\par
  436       \{\par
  437          text_space = -2.0 - text_distance ;\par
  438       \}\par
  439     else\par
  440       \{\par
  441          text_space = -1.0 - text_distance ;         \par
  442       \}\par
  443      /* x0, y0, x1 y1 but it has to be square for the fonts*/\par
  444     return_value= pl_fspace(text_space / radius, \par
  445                 text_space / radius, \par
  446                 (10.0 - text_space) / radius, \par
  447                 (10.0 - text_space) / radius );\par
  448 if(return_value)\par
  449 \{   fprintf(stderr,"fspace returned %d!\\n",return_value);   \}\par
  450 \par
  451 \par
  452 /* we should be ready to plot bars, now! */\par
  453 \par
  454 \par
  455  \par
  456 /* plot title if there is one */\par
  457 if(title&&*title)\par
  458 \{\par
  459         pl_ffontsize (0.5);\par
  460         pl_fmove( 5, 11 ) ;\par
  461     pl_alabel('c','c',title); /* centered */\par
  462 \}\par
  463 /* plot X axis title if there is one */\par
  464 if(xtext&&*xtext)\par
  465 \{\par
  466         pl_ffontsize (0.5);\par
  467         pl_fmove( 5, 0.7 * text_space ) ;\par
  468     pl_alabel('c','c',xtext); /* cnetered */\par
  469 \}\par
  470 /* plot Y axis title if there is one */\par
  471 if(mytext&&*mytext)\par
  472 \{\par
  473         pl_ffontsize (0.5);\par
  474         pl_fmove( 0.8 * text_space, 6 ) ;\par
  475         pl_ftextangle (90);\par
  476     pl_alabel('c','c',mytext); \par
  477         pl_ftextangle (0); \par
  478 \}\par
  479 /* find y max */\par
  480     \par
  481     while ( ymax < slice_max )\par
  482        \{\par
  483       ymax = ymax * nf [n] ;\par
  484       n ++ ;\par
  485       if ( nf[n] ) n = 0 ;\par
  486        \}\par
  487     pl_line ( 0,0,0, 10.0 *  ymax / slice_max  );\par
  488 /* plot Y axis */\par
  489     while ( ystep < ymax ) \par
  490      \{\par
  491     pl_fline ( -0.3, 10 * (double) ystep/ slice_max ,0.0, 10 * ystep / slice_max );\par
  492     pl_fmove ( 0.3 * text_space , 10 * (double) ystep / slice_max  );\par
  493     sprintf ( buffer, "%d", ystep );\par
  494     pl_alabel ( 'r','c', buffer );  \par
  495     ystep = ystep + ymax / 10;\par
  496     if (ystep < 1 ) ystep ++ ;\par
  497      \}  \par
  498 \par
  499 \par
  500      pl_pencolorname(LINECOLOR);\par
  501 \par
  502 /* and now for the bars     */\par
  503 \{\par
  504 \par
  505     char **color=colortable;\par
  506 \par
  507     pl_savestate();\par
  508     pl_joinmod("round");\par
  509     \par
  510     pl_filltype(1);\par
  511     pl_flinewidth(LINEWIDTH);\par
  512     pl_pencolorname(LINECOLOR);\par
  513     for(t=0;t<n_slices;t++)\par
  514 \par
  515     \{\par
  516         pl_fillcolorname(*color);\par
  517         pl_fbox (10.0 * (double)(t)/(double)(n_slices),\par
  518          0,\par
  519          10.0 * (double)(t+1)/(double)(n_slices),\par
  520          10 * slices[t]->value/slice_max );\par
  521     color++;        /* next color for next slice        */\par
  522     if(!*color) color=colortable;/* start over if all colors used   */\par
  523     \} /* end of for each slice */\par
  524 \par
  525     pl_restorestate();\par
  526 \}\par
  527 \par
  528 /* and now for the text     */\par
  529 \{\par
  530     char just ;\par
  531     just = 'c';\par
  532    \par
  533     pl_savestate();\par
  534     pl_ffontsize (0.4);\par
  535     if (n_slices > 5)\par
  536      \{\par
  537     pl_ftextangle (90); /* degrees */\par
  538     just = 'r' ;\par
  539      \}\par
  540     for(t=0;t<n_slices;t++) \par
  541     \{\par
  542 /* plot now!                */\par
  543     pl_fmove(10.0 * (double)(t+0.5)/(double)(n_slices),\par
  544          0.3 * text_space );\par
  545     pl_alabel(just, 'c' ,slices[t]->text);\par
  546     \}\par
  547     pl_restorestate();\par
  548 \}\par
  549      \} /* end of is ! Pie */\par
  550 \par
  551                 /* end a plot sesssion          */\par
  552 return_value= pl_closepl();\par
  553 if(return_value<0)\par
  554 \{   fprintf(stderr,"The plotter could not be closed.\\n");\par
  555     /* no exit, because we try to delete the plotter        */\par
  556 \}\par
  557                 \par
  558 /* need to select a different plotter in order to deleter our       */\par
  559 return_value=pl_selectpl(0);\par
  560 if(return_value<0)\par
  561 \{   fprintf(stderr,"Default Plotter could not be selected!\\n");\par
  562 \}\par
  563 \par
  564 return_value=pl_deletepl (handle);/* clean up by deleting used plotter  */\par
  565 if(return_value<0)\par
  566 \{   fprintf(stderr,"Selected Plotter could not be deleted!\\n");\par
  567 \}\par
  568 \par
  569             \par
  570 return 0;\par
  571 \}\par
  572 \par
  573 \par
  574 /************************************************************************\par
  575  * functions\par
  576  */\par
  577  \par
  578 void process_arguments( int argc, char **argv, \par
  579     char **display_type, char ** title, char ** xtext, char ** ytext,\par
  580     int * isPie, double *radius, double *text_distance,char *colortable[])\par
  581 \{\par
  582 /* well, we do not have the gnu getopt long here. :-( \par
  583  * so i use getopt for now\par
  584  */\par
  585           int c;        \par
  586           extern char *optarg;\par
  587       /* optint,opterr,optopt relate to getopt(),see manpage*/\par
  588       /* but we do not use them so far          */\par
  589           /* extern int optind,opterr,optopt; */ \par
  590           int errflg = 0;\par
  591           int show_usage=0;\par
  592           int show_version=0;\par
  593       int specified_display_type=0;\par
  594       char **help;  /* will help splitting the colornames   */\par
  595       char * arg;   /* one string argument          */\par
  596 *isPie = 0 ; /* ie do a bar chart */\par
  597 progname=argv[0];   /* fill the only global variable    */\par
  598 \par
  599           while ((c = getopt(argc, argv, "Vt:T:r:d:C:h:X:Y:P")) != EOF)\par
  600                switch (c) \{\par
  601 /* chris did some debugging here */\par
  602         case 't':\par
  603 #ifdef DEBUG\par
  604         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  605 #endif        \par
  606                          *title=xstrdup(optarg);\par
  607 #ifdef DEBUG\par
  608           fprintf (stderr, "OK \\n");\par
  609 #endif        \par
  610           break;\par
  611         case 'X':\par
  612 #ifdef DEBUG\par
  613         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  614 #endif        \par
  615                          *xtext=xstrdup(optarg);\par
  616 #ifdef DEBUG\par
  617           fprintf (stderr, "OK \\n");\par
  618 #endif        \par
  619           break;\par
  620         case 'Y':\par
  621 #ifdef DEBUG\par
  622         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  623 #endif        \par
  624                          *ytext=xstrdup(optarg);\par
  625 #ifdef DEBUG\par
  626           fprintf (stderr, "OK \\n");\par
  627 #endif        \par
  628           break;\par
  629           \par
  630                case 'T':\par
  631 #ifdef DEBUG\par
  632         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  633 #endif        \par
  634                     if (specified_display_type)\par
  635                          errflg++;\par
  636                     else \{\par
  637                 specified_display_type++;\par
  638                 *display_type = xstrdup(optarg);\par
  639             \}\par
  640 #ifdef DEBUG\par
  641           fprintf (stderr, "OK \\n");\par
  642 #endif        \par
  643           break;\par
  644            case 'P':\par
  645 #ifdef DEBUG\par
  646         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  647 #endif        \par
  648                 *isPie = 1 ;\par
  649 /* ie try to plot as pie chart */                   \par
  650 #ifdef DEBUG\par
  651         fprintf(stderr," OK \\n");\par
  652 #endif        \par
  653           break;\par
  654 \par
  655         case 'r':\par
  656 #ifdef DEBUG\par
  657         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  658 #endif        \par
  659                 *radius=atof(optarg);\par
  660                 if(*radius<0.1||*radius>1.2)\par
  661                 errflg++;\par
  662 #ifdef DEBUG\par
  663           fprintf (stderr, "OK \\n");\par
  664 #endif        \par
  665           break;\par
  666             \par
  667            case 'd':\par
  668 #ifdef DEBUG\par
  669         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  670 #endif        \par
  671                 *text_distance=atof(optarg);\par
  672                 if(*text_distance<(-2.0)||*text_distance>1.2)\par
  673                 errflg++;\par
  674             /* we have a second check after processing all options*/\par
  675 #ifdef DEBUG\par
  676           fprintf (stderr, "OK \\n");\par
  677 #endif        \par
  678           break;\par
  679             \par
  680            case 'C':\par
  681 #ifdef DEBUG\par
  682         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  683 #endif        \par
  684             help=colortable;\par
  685             arg=xstrdup(optarg);\par
  686             *help++=strtok(arg,",\\0");\par
  687             if(!*help)\par
  688                 errflg++;\par
  689             else\par
  690                 while((*(help++)=strtok(NULL,",\\0")));\par
  691 #ifdef DEBUG\par
  692           fprintf (stderr, "OK \\n");\par
  693 #endif        \par
  694           break;\par
  695             \par
  696                case 'V':\par
  697 #ifdef DEBUG\par
  698         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  699 #endif        \par
  700                     if (show_version)\par
  701                          errflg++;\par
  702                     else\par
  703                          show_version++;\par
  704 #ifdef DEBUG\par
  705           fprintf (stderr, "OK \\n");\par
  706 #endif        \par
  707           break;\par
  708                case 'h':\par
  709 #ifdef DEBUG\par
  710         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  711 #endif        \par
  712                     if (show_usage)\par
  713                          errflg++;\par
  714                     else\par
  715                          show_usage++;\par
  716 #ifdef DEBUG\par
  717           fprintf (stderr, "OK \\n");\par
  718 #endif        \par
  719           break;\par
  720                case '?':\par
  721 #ifdef DEBUG\par
  722         fprintf(stderr,"Reading switch %c arg %s ", c, optarg);       \par
  723 #endif        \par
  724                     errflg++;\par
  725                \}\par
  726                     /* check if text_distance is reasonable */\par
  727       if(*text_distance< (-*radius)) errflg++;\par
  728       if (! (*isPie) ) *radius = sqrt ( *radius ) ; /* for bar charts only */\par
  729                                            /* or else the size gets too small to see */\par
  730           if (errflg) \{ \par
  731                fprintf(stderr, "parameters were bad!\\n");\par
  732                show_usage++;\par
  733           \}\par
  734           if(show_version)\par
  735           \{\par
  736              print_version(stdout); \par
  737              exit(1);\par
  738           \}\par
  739           if(show_usage)\par
  740           \{ FILE *f=stdout;\par
  741         if(errflg)\par
  742                     f=stderr;\par
  743         else    f=stdout;\par
  744          print_version(f);\par
  745         \par
  746              fprintf(f,"usage: %s [options]\\n",progname); \par
  747              fprintf(f,"\\t the stdin is read once.\\n");\par
  748              fprintf(f,"\\t options are:\\n"\\\par
  749                     "\\t\\t-P Use Pie rather than Bar chart ( not -X -Y )\\n"\\\par
  750                     "\\t\\t-t Title\\tset \\"Title\\" as chart title\\n"\\\par
  751                     "\\t\\t-X XTitle\\tset \\"XTitle\\" as barchart X axis title\\n"\\\par
  752                     "\\t\\t-Y YTitle\\tset \\"YTitle\\" as barchart Y axis title\\n"\\\par
  753                     "\\t\\t-T Display-Type\\tone of "\\\par
  754                 "X, ps, fig, hpgl, tek, meta, ai, pnm, gif\\n"\\\par
  755             "\\t\\t\\t\\t(or whatever your libplot version supports)\\n"\\\par
  756             "\\t\\t\\t\\t(meta is the default)\\n"\\\par
  757                     "\\t\\t-r size of chart\\tfloat out of [0.1;1.2] default:0.8\\n"\\\par
  758                     "\\t\\t-d textdistance around chart \\tfloat out of "\\\par
  759                         "[-radius;1.2] default:0.0\\n"\\\par
  760             "\\t\\t-C colornames\\tcomma separated list of colornames\\n"\\\par
  761             "\\t\\t\\t\\t(see valid names in color.txt of plotutils doc.)\\n"\\\par
  762                     "\\t\\t-h\\t\\tprint this help and exit\\n"\\\par
  763                     "\\t\\t-V\\t\\tprint version and exit\\n"\\\par
  764                     );\par
  765              \par
  766              exit(1);\par
  767           \}\par
  768 \par
  769 /* Everything is fine with the options now ... */\par
  770 \}\par
  771 \par
  772 \par
  773 void read_stdin(int *n_slices, struct slice *slices[MAXSLICES])\par
  774 \{\par
  775 char line [LINE_BUFSIZ];        /* input line buffer            */\par
  776 \par
  777 /* So, let us read the standardinput */\par
  778 while( !(feof(stdin) || ferror(stdin)) )\par
  779 \{\par
  780 char *c;            /* string return from fgets     */\par
  781 struct slice * aslice;      /* freshly filled slice-structure   */\par
  782 int r;              /* help variable for scanning       */\par
  783 char *s,*t;         /* help variables for scanning      */\par
  784 \par
  785     c=fgets(line,LINE_BUFSIZ,stdin);\par
  786     if(!c) continue;    /* encountered error of eof     */\par
  787     if(line[strlen(line)-1]!='\\n')\par
  788     \{\par
  789         fprintf(stderr,"line was too long!\\n");\par
  790         exit(2);\par
  791     \}\par
  792                 /* strip newline */\par
  793     line[strlen(line)-1]='\\0';\par
  794                 /* strip carridge return, if there is one*/\par
  795     if(line[strlen(line)-1]=='\\r') \par
  796         line[strlen(line)-1]='\\0';\par
  797     \par
  798                 /* Skip empty lines or lines beginning  \par
  799                  * with COMMENTCHAR         */\par
  800     if(!(line[0]==COMMENTCHAR || !(line) || strlen(line)==0))\par
  801     \{\par
  802 #ifdef DEBUG\par
  803         fprintf(stderr,"Scanning line: %s\\n",line);\par
  804 #endif\par
  805         aslice=malloc(sizeof(struct slice));\par
  806         if(!aslice)\par
  807             perror(progname),exit(10);\par
  808             \par
  809             \par
  810                 /* scanning the last part\par
  811                  * after a tab or space as number   */\par
  812                  \par
  813                 /* delete trailing tabs and spaces  */\par
  814         r=strlen(line);\par
  815         while(r>0 && (line[r-1]==' ' || line[r-1]=='\\t') )\par
  816             line[r---1]='\\0';\par
  817                 /* scan for last tab or space       */\par
  818         s=strrchr(line,' ');\par
  819         t=strrchr(line,'\\t');\par
  820         s=(s>t?s:t);    /* which is the last white-space?   */\par
  821             \par
  822                 /*use full string,if no whitespace found\par
  823                 else copy text up to whitespace\par
  824                 and get enough memory           */\par
  825         if(s==NULL) \par
  826         \{\par
  827             if(!(aslice->text=malloc(1))) \par
  828                 perror(progname),exit(10);\par
  829             aslice->text[0]='\\0'; \par
  830             s=line;\par
  831         \} else\par
  832         \{   \par
  833             if(!(aslice->text=malloc(strlen(line)-strlen(s)+1))) \par
  834                 perror(progname),exit(10);\par
  835             strncpy(aslice->text,line, strlen(line)-strlen(s));\par
  836                 /*some systems don`t terminate target \par
  837                 string in strncpy, so we have to do it  */\par
  838             aslice->text[strlen(line)-strlen(s)]='\\0';\par
  839         \}\par
  840         \par
  841                 /* scan last string for number      */\par
  842         r=sscanf(s,"%lf",&aslice->value);\par
  843         if(r!=1)\par
  844             fprintf(stderr,"number in line couldn`t be scanned\\n"),\par
  845                 exit(8);\par
  846         \par
  847         if(*n_slices>=MAXSLICES)\par
  848             fprintf(stderr,"too many slices\\n"),exit(8);\par
  849             \par
  850         slices[(*n_slices)++]=aslice;\par
  851     \}\par
  852 \}\par
  853 \par
  854 if(ferror(stdin))\par
  855 \{\par
  856     perror(progname);\par
  857     exit(5);\par
  858 \}\par
  859 \par
  860 #ifdef DEBUG\par
  861 fprintf(stderr,"Read %d slices!\\n",*n_slices);\par
  862 #endif \par
  863 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
constants.h File Reference\par \pard\plain 
{\tc\tcl2 \v constants.h}
{\xe \v constants.h}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "constants_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b M_E}\~ 2.71828182845904523536\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b M_LOG2E}\~ 1.44269504088896340736\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b M_LOG10E}\~ 0.434294481903251827651\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b M_LN2}\~ 0.693147180559945309417\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b M_LN10}\~ 2.30258509299404568402\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b M_PI}\~ 3.14159265358979323846\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b M_PI_2}\~ 1.57079632679489661923\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b M_PI_4}\~ 0.785398163397448309616\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b M_1_PI}\~ 0.318309886183790671538\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b M_2_PI}\~ 0.636619772367581343076\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b M_1_SQRTPI}\~ 0.564189583547756286948\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b M_2_SQRTPI}\~ 1.12837916709551257390\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b M_SQRT2}\~ 1.41421356237309504880\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b M_SQRT_2}\~ 0.707106781186547524401\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v M_1_PI\:constants.h}
{\xe \v constants.h\:M_1_PI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define M_1_PI\~ 0.318309886183790671538}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b constants.h}.}\par
}
{\xe \v M_1_SQRTPI\:constants.h}
{\xe \v constants.h\:M_1_SQRTPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define M_1_SQRTPI\~ 0.564189583547756286948}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b constants.h}.}\par
}
{\xe \v M_2_PI\:constants.h}
{\xe \v constants.h\:M_2_PI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define M_2_PI\~ 0.636619772367581343076}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b constants.h}.}\par
}
{\xe \v M_2_SQRTPI\:constants.h}
{\xe \v constants.h\:M_2_SQRTPI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define M_2_SQRTPI\~ 1.12837916709551257390}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b constants.h}.}\par
}
{\xe \v M_E\:constants.h}
{\xe \v constants.h\:M_E}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define M_E\~ 2.71828182845904523536}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2} of file {\b constants.h}.}\par
}
{\xe \v M_LN10\:constants.h}
{\xe \v constants.h\:M_LN10}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define M_LN10\~ 2.30258509299404568402}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b constants.h}.}\par
}
{\xe \v M_LN2\:constants.h}
{\xe \v constants.h\:M_LN2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define M_LN2\~ 0.693147180559945309417}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b constants.h}.}\par
}
{\xe \v M_LOG10E\:constants.h}
{\xe \v constants.h\:M_LOG10E}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define M_LOG10E\~ 0.434294481903251827651}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4} of file {\b constants.h}.}\par
}
{\xe \v M_LOG2E\:constants.h}
{\xe \v constants.h\:M_LOG2E}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define M_LOG2E\~ 1.44269504088896340736}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b constants.h}.}\par
}
{\xe \v M_PI\:constants.h}
{\xe \v constants.h\:M_PI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define M_PI\~ 3.14159265358979323846}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b constants.h}.}\par
}
{\xe \v M_PI_2\:constants.h}
{\xe \v constants.h\:M_PI_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define M_PI_2\~ 1.57079632679489661923}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b constants.h}.}\par
}
{\xe \v M_PI_4\:constants.h}
{\xe \v constants.h\:M_PI_4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define M_PI_4\~ 0.785398163397448309616}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b constants.h}.}\par
}
{\xe \v M_SQRT2\:constants.h}
{\xe \v constants.h\:M_SQRT2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define M_SQRT2\~ 1.41421356237309504880}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b constants.h}.}\par
}
{\xe \v M_SQRT_2\:constants.h}
{\xe \v constants.h\:M_SQRT_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define M_SQRT_2\~ 0.707106781186547524401}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b constants.h}.}\par
}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
constants.h\par \pard\plain 
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     1 /* Constants rounded for 21 decimals. */\par
    2 #define M_E 2.71828182845904523536\par
    3 #define M_LOG2E 1.44269504088896340736\par
    4 #define M_LOG10E 0.434294481903251827651\par
    5 #define M_LN2 0.693147180559945309417\par
    6 #define M_LN10 2.30258509299404568402\par
    7 #define M_PI 3.14159265358979323846\par
    8 #define M_PI_2 1.57079632679489661923\par
    9 #define M_PI_4 0.785398163397448309616\par
   10 #define M_1_PI 0.318309886183790671538\par
   11 #define M_2_PI 0.636619772367581343076\par
   12 #define M_1_SQRTPI 0.564189583547756286948\par
   13 #define M_2_SQRTPI 1.12837916709551257390\par
   14 #define M_SQRT2 1.41421356237309504880\par
   15 #define M_SQRT_2 0.707106781186547524401\par
   16 \par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}